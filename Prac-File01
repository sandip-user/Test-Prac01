using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

namespace TestConsoleApp001
{
    class Program
    {
        #region Public string Members
        public static string[] ones = { "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" };
        public static string[] teens = { "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eightteen", "nineteen" };
        public static string[] tens = { "ten", "twenty", "thirty", "fourty", "fifty", "sixty", "seventy", "eightty", "ninety" };
        public static string[] bigs = { "", "thousand", "million", "billion", "trillion", "zillion" };
        #endregion

        #region Public Stack Members
        static int[] stackArray;
        static int NumberOfStacks = 3;
        static int DefaultSize = 8;
        static int TotalSize = DefaultSize * NumberOfStacks;
        static ulong tc = 0;

        public static Dictionary<string, int> knownCount = new Dictionary<string, int>();

        static StackData[] Stacks =
        {
            new StackData(0, DefaultSize),
            new StackData(DefaultSize, DefaultSize),
            new StackData(DefaultSize * 2, DefaultSize)
        };

        static int[] Buffer = new int[TotalSize];
        #endregion

        static void Main(string[] args)
        {

            #region Solved Ones

            //petrol pump
            //int[,] arr = { { 6, 4 }, { 9, 6 }, { 7, 3 }, { 6, 5 }, { 4, 5 } };
            //Console.WriteLine(StartTour(arr));

            //LRU cache
            //// Let cache can hold 4 pages
            //LRUCache cache = LRUCache.CreateLRUCache(5);
            //// Let 10 different pages can be requested (pages to be
            //// referenced are numbered from 0 to 9
            //LRUCache.PageFrame frame = LRUCache.PageFrame.CreatePageFrame(25);
            //// Let us refer pages
            //Random rand = new Random();
            //for (int index = 0; index < 25; index++)
            //{
            //    uint temp = (uint)rand.Next(1, 5);
            //    cache.ReferencePage(cache, frame, temp);
            //}
            //// Let us print cache frames after the above referenced pages
            //Console.WriteLine(cache.front.pageNumber);
            //Console.WriteLine(cache.front.next.pageNumber);
            //Console.WriteLine(cache.front.next.next.pageNumber);
            //Console.WriteLine(cache.front.next.next.next.pageNumber);

            //Sample Tree
            //TreeNode root = new TreeNode(5)
            //{
            //    Left = new TreeNode(3)
            //    {
            //        Left = new TreeNode(2)
            //        {
            //            Left = new TreeNode(1)
            //            {
            //                Left = null,
            //                Right = null,
            //            },
            //            Right = null,
            //        },
            //        Right = new TreeNode(4)
            //        {
            //            Left = null,
            //            Right = null,
            //        },
            //    },
            //    Right = new TreeNode(8)
            //    {
            //        Left = new TreeNode(7)
            //        {
            //            Left = new TreeNode(6)
            //            {
            //                Left = null,
            //                Right = null,
            //            },
            //            Right = null,
            //        },
            //        Right = new TreeNode(9)
            //        {
            //            Left = null,
            //            Right = null,
            //        },
            //    },
            //};

            ////path sum
            ////List<int> op1 = new List<int>();
            ////var op2 = IsPathExists(root, 12, out op1);
            ////var op3 = BuildTree(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, new int[] { 1, 2, 4, 3, 6, 7, 9, 8, 5 });

            ////runnign number Avg
            ////Random rand = new Random(250);
            ////for (int index = 0; index <= 25; index++)
            ////{
            ////    int next = rand.Next(250, 2500);
            ////    Console.WriteLine("{0}: {1}", next, RunningNumber.Avg(next));
            ////}

            ////int[] t = new int[25];
            ////for (int i = 0; i < 25; i++)
            ////{
            ////    t[i] = i + 100;
            ////}
            ////for (int j = 0; j < t.Length; j++)
            ////{
            ////    var temp = t[t.Length - j - 1];
            ////    t[t.Length - j - 1] = t[j];
            ////    t[j] = temp;
            ////}

            //LCA
            //var op = findLCA(root, 9, 6);

            //AVL Tree
            //AVLTree avlRoot = new AVLTree(6);
            //for (int index = 0; index < 10; index++)
            //{
            //    if (index != 5)
            //    {
            //        avlRoot.Add(index + 1);
            //    }
            //}

            //Vertical Sum
            //DoublyLinkedList Sums = GetVerticalSums(root);
            //while(Sums != null)
            //{
            //    Console.WriteLine(Sums.Sum + " ");
            //    Sums = Sums.Next;
            //}

            //TreeNode from ancestor and vice versa
            //int[,] matrix = new int[,] {{ 0, 0, 0, 0, 0, 0 }, { 1, 0, 0, 0, 1, 0 }, { 0, 0, 0, 1, 0, 0 }, { 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0 }, { 1, 1, 1, 1, 1, 0 }};
            //var op = AncestorTree(matrix);
            //PrintInorder(op);
            //var op1 = ancestorMatrix(op);

            //test trie
            //string[] testIP = new string[] { "d o g . c o m", "d o g f o o d . c o m", "d o o d l e . c o m", "d o g g y . c o m", "d o g . c o m / h e l p",
            //    "g o d . c o m", "g o d . c o m / h e l p", "n e t f l i x . c o m", "n e t f l i x . c o m / b r o w s e" };
            //TrieNode root = new TrieNode();
            //foreach (var item in testIP)
            //{
            //    root.Insert(new List<string>(item.Split(" ".ToCharArray(), StringSplitOptions.RemoveEmptyEntries)), item.Length);
            //}
            //foreach (var item in testIP)
            //{
            //    Console.WriteLine("Found {0} in trie: {1}", item.Replace(" ", ""), root.Search(new List<string>(item.Split(" ".ToCharArray(),
            //        StringSplitOptions.RemoveEmptyEntries))));
            //}

            //FractionToDecimal
            //Console.WriteLine("20/3: " + FractionToDecimal(20, 3));
            //Console.WriteLine("1/2: " + FractionToDecimal(1, 2));
            //Console.WriteLine("4/2: " + FractionToDecimal(4, 2));
            //Console.WriteLine("2/3: " + FractionToDecimal(2, 3));

            //Shuffle
            //Stopwatch watch = new Stopwatch();
            //watch.Reset();
            //watch.Start();
            //int[] ip = new int[] { 1, 2, 3, 4, 5, 6 };
            //KnuthShuffle(ip);
            //watch.Stop();
            //Console.WriteLine(watch.Elapsed + "ms");
            //watch.Reset();
            //watch.Start();
            //ip = new int[] { 1, 2, 3, 4, 5, 6, 7 };
            //MyShuffle(ip);
            //watch.Stop();
            //Console.WriteLine(watch.Elapsed + "ms");

            //min palindrome partition
            //Console.WriteLine(MinPalindromePartion("ababbbabbababa"));
            ////Reverse String without special chars
            //Console.WriteLine(new string(SpecialReverse(Console.ReadLine().ToCharArray())));

            //Isomorphic
            //Stopwatch watch = new Stopwatch();
            //watch.Reset();
            //watch.Start();
            //Console.WriteLine(AreIsomorphic("abcdefghgfdacbeefdfdg", "1234567%7641325564647"));
            //watch.Stop();
            //Console.WriteLine(watch.ElapsedMilliseconds + "ms");
            //watch.Reset();
            //watch.Start();
            //Console.WriteLine(AreIsomorphic("abcdefghgfdacbeefdfdg", "1294567%7641325564647"));
            //watch.Stop();
            //Console.WriteLine(watch.ElapsedMilliseconds + "ms");

            //excel columns
            //Console.WriteLine(TitleToNumber("Z"));
            //Console.WriteLine(TitleToNumber("AY"));
            //Console.WriteLine(TitleToNumber("AZ"));
            //Console.WriteLine(TitleToNumber("CB"));
            //Console.WriteLine(TitleToNumber("YZ"));
            //Console.WriteLine(TitleToNumber("ZZ"));
            //Console.WriteLine(TitleToNumber("AAC"));
            //Console.WriteLine(NumberToTitle(26));
            //Console.WriteLine(NumberToTitle(51));
            //Console.WriteLine(NumberToTitle(52));
            //Console.WriteLine(NumberToTitle(80));
            //Console.WriteLine(NumberToTitle(676));
            //Console.WriteLine(NumberToTitle(702));
            //Console.WriteLine(NumberToTitle(705));

            //test            
            //LinkedListNode node = new LinkedListNode()
            //{
            //    Data = 1,
            //    Next = new LinkedListNode()
            //    {
            //        Data = 2,
            //        Next = new LinkedListNode()
            //        {
            //            Data = 3,
            //            Next = new LinkedListNode()
            //            {
            //                Data = 4,
            //                Next = new LinkedListNode()
            //                {
            //                    Data = 5,
            //                    Next = new LinkedListNode()
            //                    {
            //                        Data = 6,
            //                        Next = new LinkedListNode()
            //                        {
            //                            Data = 7,
            //                            Next = new LinkedListNode()
            //                            {
            //                                Data = 8,
            //                                Next = new LinkedListNode()
            //                                {
            //                                    Data = 9,
            //                                    Next = new LinkedListNode()
            //                                    {
            //                                        Data = 10,
            //                                        Next = new LinkedListNode()
            //                                        {
            //                                            Data = 11,
            //                                            Next = new LinkedListNode()
            //                                            {
            //                                                Data = 12,
            //                                                Next = new LinkedListNode()
            //                                                {
            //                                                    Data = 13,
            //                                                    Next = new LinkedListNode()
            //                                                    {
            //                                                        Data = 14,
            //                                                        Next = new LinkedListNode()
            //                                                        {
            //                                                            Data = 15,
            //                                                            Next = new LinkedListNode()
            //                                                            {
            //                                                                Data = 16,
            //                                                                Next = new LinkedListNode()
            //                                                                {
            //                                                                    Data = 17,
            //                                                                    Next = new LinkedListNode()
            //                                                                    {
            //                                                                        Data = 18,
            //                                                                        Next = new LinkedListNode()
            //                                                                        {
            //                                                                            Data = 19,
            //                                                                            Next = new LinkedListNode()
            //                                                                            {
            //                                                                                Data = 20,
            //                                                                                Next = null,
            //                                                                            }
            //                                                                        }
            //                                                                    }
            //                                                                }
            //                                                            }
            //                                                        }
            //                                                    }
            //                                                }
            //                                            }
            //                                        }
            //                                    }
            //                                }
            //                            }
            //                        }
            //                    }
            //                }
            //            }
            //        }
            //    }
            //};

            //LinkedListNode chead = node.Next.Next.Next.Next.Next.Next.Next.Next.Next.Next.Next;
            //node.Next.Next.Next.Next.Next.Next.Next.Next.Next.Next.Next.Next.Next.Next.Next.Next.Next.Next.Next.Next = chead;

            //var test = FindCircularHead(node);

            //Large multiply
            //Console.WriteLine(Multiply(Console.ReadLine(), Console.ReadLine()));

            //Unusual Divide
            //int temp;
            //Console.WriteLine(UnusualDivide(int.Parse(Console.ReadLine()), int.Parse(Console.ReadLine()), out temp));
            //Console.WriteLine(temp);

            //Knuth shuffle
            //int[] ip = new int[] { 1, 2, 3, 4, 5, 6 };
            //KnuthShuffle(ip);

            //Word-Cloud
            //string ip = @"After beating the eggs, Dana read the next step: Add milk and eggs, then add flour and sugar. "
            //    + "After beating the eggs, Dana read the next step: Add milk and eggs, then add flour and sugar. " 
            //    + "After beating the eggs, Dana read the next step: Add milk and eggs, then add flour and sugar. " 
            //    + "After beating the eggs, Dana read the next step: Add milk and eggs, then add flour and sugar. "
            //    + "After beating the eggs, Dana read the next step: Add milk and eggs, then add flour and sugar. " 
            //    + "After beating the eggs, Dana read the next step: Add milk and eggs, then add flour and sugar.";
            //var op = BuildStrCloud(ip);
            //foreach (var item in op)
            //{
            //    Console.WriteLine("{0}:{1}", item.Key, item.Value);
            //}

            //FindNumberAppearingTwice
            //int[] arr = new int[1001];
            //for (int index = 1; index <= arr.Length; index++)
            //{
            //    arr[index - 1] = index;
            //}
            //arr[1000] = 507;
            //Console.WriteLine(FindNumberAppearingTwice(arr));

            //Sorting compatison of times
            //for (int i = 0; i < 5; i++)
            //{
            //    Console.WriteLine("Iteration-" + i);
            //    Stopwatch watch = new Stopwatch();
            //    var arrs = GetRandomArray1();

            //    //Counting Sort
            //    Console.WriteLine("countingsort");
            //    int[] items2 = CopyArray1(arrs[1]);
            //    int[] items = CopyArray1(arrs[0]);
            //    watch.Start();
            //    items = CountingSort(items);
            //    watch.Stop();
            //    Console.WriteLine(watch.ElapsedMilliseconds + "ms");
            //    watch.Reset();
            //    watch.Start();
            //    items2 = CountingSort(items2);
            //    watch.Stop();
            //    Console.WriteLine(watch.ElapsedMilliseconds + "ms");

            //    //Merge sort
            //    Console.WriteLine("MergeSort");
            //    items2 = CopyArray1(arrs[1]);
            //    items = CopyArray1(arrs[0]);
            //    watch.Reset();
            //    watch.Start();
            //    items = MergeSort(items);
            //    watch.Stop();
            //    Console.WriteLine(watch.ElapsedMilliseconds + "ms");
            //    watch.Reset();
            //    watch.Start();
            //    items2 = MergeSort(items2);
            //    watch.Stop();
            //    Console.WriteLine(watch.ElapsedMilliseconds + "ms");

            //    //insertion sort
            //    Console.WriteLine("InsertionSort");
            //    items2 = CopyArray1(arrs[1]);
            //    items = CopyArray1(arrs[0]);
            //    watch.Reset();
            //    watch.Start();
            //    InsertionSort(items);
            //    watch.Stop();
            //    Console.WriteLine(watch.ElapsedMilliseconds + "ms");
            //    watch.Reset();
            //    watch.Start();
            //    InsertionSort(items2);
            //    watch.Stop();
            //    Console.WriteLine(watch.ElapsedMilliseconds + "ms");

            //    //Heap sort
            //    Console.WriteLine("HeapSort");
            //    items2 = CopyArray1(arrs[1]);
            //    items = CopyArray1(arrs[0]);
            //    watch.Reset();
            //    watch.Start();
            //    HeapSort(items);
            //    watch.Stop();
            //    Console.WriteLine(watch.ElapsedMilliseconds + "ms");
            //    watch.Reset();
            //    watch.Start();
            //    HeapSort(items2);
            //    watch.Stop();
            //    Console.WriteLine(watch.ElapsedMilliseconds + "ms");

            //    //Quick sort
            //    Console.WriteLine("Quick Sort");
            //    items2 = CopyArray1(arrs[1]);
            //    items = CopyArray1(arrs[0]);
            //    watch.Reset();
            //    watch.Start();
            //    QuickSort(items);
            //    watch.Stop();
            //    Console.WriteLine(watch.ElapsedMilliseconds + "ms");
            //    watch.Reset();
            //    watch.Start();
            //    QuickSort(items2);
            //    watch.Stop();
            //    Console.WriteLine(watch.ElapsedMilliseconds + "ms");
            //}

            //Find Unique In Duplicates
            //int[] list = new int[] { 10,12,14,16,15,14,10,12,18,19,15,19,16 };
            //Console.WriteLine(FindUniqueInDuplicates(list));

            //bracket validator
            //string t1 = "(),{},[],<>";
            //string t2 = "123[123(234]23<742347>4{567}23)456456";
            //string t3 = "123[234(234{567}23)6456";
            //string t5 = "123(234)4{567}23[324]642>3213<356";
            //string t4 = "123[123(234)234{5<1323>67}23]6546";
            //Console.WriteLine(BracketValidator(t2, t1));
            //Console.WriteLine(BracketValidator(t3, t1));
            //Console.WriteLine(BracketValidator(t4, t1));
            //Console.WriteLine(BracketValidator(t5, t1));

            //GetstringPermutaions
            //var test1 = GetstringPermutations("123456");
            //foreach (var item in test1)
            //{
            //    Console.WriteLine(item);
            //}
            //Console.WriteLine(test1.Count);
            //Console.WriteLine();
            //test1 = GetstringPermutations("123466");
            //foreach (var item in test1)
            //{
            //    Console.WriteLine(item);
            //}
            //Console.WriteLine(test1.Count);


            //flight entertainment
            //int[] movies = new int[] { 121, 117, 141, 151, 161, 171, 189, 169, 203, 205, 207, 209, 111};
            //List<int[]> validMovieList = new List<int[]>();
            //Console.WriteLine(GetTwoMoviesToFillFlight(movies, 320, 20, out validMovieList));
            //for (int index = 0; index < validMovieList.Count; index++)
            //{
            //    Console.WriteLine(validMovieList[index][0] + " : " + validMovieList[index][1]);
            //}

            ////detect string array rotation
            //string[] input = new string[9] { "y1", "y9", "zz99", "abc", "def", "ghij", "klmn", "opqrs", "tuvwx" };
            //string first = string.Empty;
            //Console.WriteLine("Index: {0} ; string: {1} ...", FindRotaionOfSortedArray(input, out first), first);

            //2nd largest node in BST
            //TreeNode root = TreeNode.CreateTreeFromInOrder("30,12,8,5,10,20,50,45,35,48,60,55");
            //TreeNode root = TreeNode.CreateTreeFromInOrder("30,18,12,10,8,5,3");
            //Console.WriteLine(FindSecondLargest(root));

            //Super-balanced
            //TreeNode root = TreeNode.CreateTreeFromInOrder("30,12,8,5,10,20,50,45,35,48,60,55");
            //Console.WriteLine(IsTreeSuperBalanced(root));

            ////FindOverlap
            //Rectangle r1 = new Rectangle(10, 15, 25, 20);
            //Rectangle r2 = new Rectangle(15, 5, 35, 25);
            //var r3 = FindRectangularOverlap(r1, r2);
            //Console.WriteLine(r3.ToString());

            //Temp-Tracker
            //Random r1 = new Random(0);
            //int range = int.Parse(Console.ReadLine());
            //TempTracker tt1 = new TempTracker(range);
            //int temp = 0;

            //for (int index = 0; index < 10; index++)
            //{
            //    temp = r1.Next(0, range);
            //    tt1.Insert(temp);
            //    Console.WriteLine("Insert: " + temp);
            //}
            //tt1.Insert(temp);
            //Console.WriteLine("Insert: " + temp);

            //Console.WriteLine("Max: " + tt1.GetMax());
            //Console.WriteLine("Min: " + tt1.GetMin());
            //Console.WriteLine("Mean: " + tt1.GetMean());
            //Console.WriteLine("Mode: " + tt1.GetMode());

            //MergeMeetings
            //List<Meeting> meetings = new List<Meeting>() { new Meeting(7, 10), new Meeting(3, 4), new Meeting(2, 5), new Meeting(6, 8), new Meeting(1, 2) };
            //var output = MergeMeetings(meetings.ToArray());

            //var op = ProductsOfAllIntsExceptAtIndex(new int[] { 5, 6, 7, 8 });
            //foreach (var item in op)
            //{
            //    Console.WriteLine(item);
            //}

            //Console.WriteLine(FindMaxShareProfit(new int[] { 10, 12, 15, 5, 3, 8, 9, 18 }));

            //Fibbo
            //long sum;
            //var test = Fibbonachi(Console.ReadLine().Trim(), out sum);
            //Console.WriteLine(string.Format("Term: {0} and Sum: {1}", test, sum));

            //Console.WriteLine("str & n");
            //Console.WriteLine(FindLowestNumberPostRemoval(Console.ReadLine(), int.Parse(Console.ReadLine())));

            ////Powerset
            //var test = GetAllUniqueSubset("0123456789".ToCharArray());
            //foreach (var item in test)
            //    Console.WriteLine(item);

            //string ones
            //string source = string.Empty, pattern = string.Empty;
            //using (FileStream fs = new FileStream(@"D:\imp\Coder\G\TestText.txt", FileMode.Open, FileAccess.Read))
            //{
            //    var ip = new StreamReader(fs).ReadToEnd().Split(new string[] { ";%%##$$;" }, stringSplitOptions.None);
            //    source = ip[0]; pattern = ip[1];
            //}

            //int[,] graph = new int[,] 
            //{
            //    { 0, 4, 0, 0, 0, 0, 0, 8, 0 },
            //    {4, 0, 8, 0, 0, 0, 0, 11, 0},
            //    {0, 8, 0, 7, 0, 4, 0, 0, 2},
            //    {0, 0, 7, 0, 9, 14, 0, 0, 0},
            //    {0, 0, 0, 9, 0, 10, 0, 0, 0},
            //    {0, 0, 4, 0, 10, 0, 2, 0, 0},
            //    {0, 0, 0, 14, 0, 2, 0, 1, 6},
            //    {8, 11, 0, 0, 0, 0, 1, 0, 7},
            //    {0, 0, 2, 0, 0, 0, 6, 7, 0}
            //};

            //ShortestPath.dijkstra(graph, 0);



            //NQueens
            //var test = FindNQueens(8);

            //Duplicate
            //var test = Mystring_Duplicate(pattern.ToCharArray(), pattern.ToCharArray());
            //var test1 = Mystring_Duplicate(source.ToCharArray(), pattern.ToCharArray());

            //Contains
            //var res = Mystring_Contains(source.Trim().ToCharArray(), pattern.Trim().ToCharArray());
            //Console.WriteLine(res);

            /* Make object of HashTable */
            //HashTable ht = new HashTable(50);
            //ht.Insert("abc", 10);
            //ht.Insert("def", 10);
            //ht.Insert("ghi", 10);
            //ht.Insert("jkl", 10);
            //ht.Insert("mno", 10);
            //ht.Insert("pqr", 10);
            //ht.Insert("xyz", 10);
            //ht.Remove("jkl");
            ////ht.Get("jkl");
            //ht.Get("pqr");
            //ht.GetSize();
            //ht.MakeEmpty();
            //ht.IsEmpty();

            //LooknSay Series
            //var test = GetLookNSaySeries("1", 15);

            //Sorting
            //int[] arr = new int[] { 50, 30, 45, 25, 12, 40, 80, 50, 10, 61, 21, 53, 98, 74, 87, 84 };
            //int[] arr1 = new int[] { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };

            //Merge-Sort
            //var op1 = MergeSort(arr);

            //Quick-Sort
            //QuickSort(arr);

            //heap sort
            //HeapSort(arr1);

            //Find coins combinations
            //var output = FindCombinationsCount(4, new List<int>() { 1, 2, 3 });

            //Cake Thief
            //Cake[] cakes = new Cake[] { new Cake(7, 160), new Cake(3, 90), new Cake(2, 15) }; //, new Cake(50,15),
            //new Cake(10,1),  new Cake(1, 5),  new Cake(6, 140),  new Cake(5,50) };
            //MergeSortCake(cakes, 0, cakes.Length - 1);
            //int maxUtilization = MaxUtilizeDuffle(cakes, 20);

            //find kth largest & smallest
            //TreeNode root = TreeNode.CreateTreeFromInOrder("30,8,5,12,10,20,45,35,50,48,60,55");
            //Console.WriteLine("largest:");
            //Console.WriteLine(FindKthLargestNode(root, Convert.ToInt32(Console.ReadLine())).Data);
            //Console.WriteLine("smallest:");
            //Console.WriteLine(FindKthSmallestNode(root, Convert.ToInt32(Console.ReadLine())).Data);

            ////finding highest product
            //int[] arr = new[] { 10, 20, 30, -35, -25, 50, 25 };
            //long maxProduct;
            //var output = FindMaxProduct(arr, 3, out maxProduct);
            //Console.WriteLine(maxProduct);
            //foreach (var item in output)
            //{
            //    Console.WriteLine(item);
            //}

            //arr = new[] { -20,10,-17,12,8,14,15,-19,5 };
            //output = FindMaxProduct(arr, 4, out maxProduct);
            //Console.WriteLine(maxProduct);
            //foreach (var item in output)
            //{
            //    Console.WriteLine(item);
            //}

            //arr = new[] { 20,19,-13,-14,-18,16,15,-17,10 };
            //output = FindMaxProduct(arr, 4, out maxProduct);
            //Console.WriteLine(maxProduct);
            //foreach (var item in output)
            //{
            //    Console.WriteLine(item);
            //}

            //Duplicate finding
            //int[] arr = new int[] {3,1,2,2};
            //Console.WriteLine(FindRepeat(arr));
            //Console.WriteLine(FindDupeAggr(arr));

            //Sol. 4-8:
            // t2 is a subtree of t1
            //int[] array1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 };
            //int[] array2 = { 2, 4, 5, 8, 9, 10, 11 };
            //var t1 = TreeNode.CreateMinimalBst(array1);
            //var t2 = TreeNode.CreateMinimalBst(array2);
            //Console.WriteLine((ContainsTree(t1, t2) ? "t2 is a subtree of t1" : "t2 is not a subtree of t1"));
            //// t4 is not a subtree of t3
            //int[] array3 = { 1, 2, 3 };
            //var t3 = TreeNode.CreateMinimalBst(array1);
            //var t4 = TreeNode.CreateMinimalBst(array3);
            //Console.WriteLine((ContainsTree(t3, t4)) ? "t4 is a subtree of t3" : "t4 is not a subtree of t3");

            //Soln. 4-7:
            //int[] array = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            //var root = TreeNode.CreateMinimalBst(array);
            //var n3 = root.Find(1);
            //var n7 = root.Find(7);
            //var ancestor = FindCommonAncesstor(root, n3, n7);
            //Console.WriteLine(ancestor.Data);


            //Soln. 4-6:
            //int[] array = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            //var root = TreeNode.CreateMinimalBst(array);
            //for (var i = 0; i < array.Length - 1; i++)
            //{
            //    var node = root.Find(array[i]);
            //    var next = InorderSucc(node);
            //    if (next != null)
            //    {
            //        Console.WriteLine(node.Data + "." + next.Data);
            //    }
            //    else
            //    {
            //        Console.WriteLine(node.Data + "." + null);
            //    }
            //}

            //Soln. 4-5:            
            //TreeNode ascTree = new TreeNode(20);
            //ascTree.Left = new TreeNode(10);
            //ascTree.Left.Left = new TreeNode(5);
            //ascTree.Left.Right = new TreeNode(25);
            //ascTree.Right = new TreeNode(30);
            //var result = IsBst(ascTree);
            //var res = ascTree.IsBst();

            //Soln. 4-4:
            //int[] nodesFlattened = new int[99999];
            //for (int counter = 1; counter <= 99999; counter++)
            //{
            //    nodesFlattened[counter - 1] = counter;
            //}
            //var root = MinimalBSTFromArr(nodesFlattened, true);
            //var clock1 = new Stopwatch();
            //for (int counter1 = 0; counter1 < 100; counter1++)
            //{
            //    clock1.Start();
            //    var list1 = CreateLevelLinkedList(root);
            //    clock1.Stop();
            //}            
            //Console.WriteLine(@"Non-recursive: {0}/100", clock1.ElapsedMilliseconds);
            //clock1.Reset();
            //for (int counter2 = 0; counter2 < 100; counter2++)
            //{
            //    clock1.Start();
            //    var list2 = CreateLevelListRecursively(root);
            //    clock1.Stop();
            //}
            //Console.WriteLine(@"Recursive: {0}/100", clock1.ElapsedMilliseconds);
            //PrintResult(list1);
            //PrintResult(list2);


            //Soln. 4-3:
            //int[] ascArr = new int[10];
            //int[] dscArr = new int[10];
            //for (int counter = 0; counter < ascArr.Length; counter++)
            //{
            //    ascArr[counter] = (counter + 5) * 10;
            //}
            //ascArr.CopyTo(dscArr, 0);
            //Array.Reverse(dscArr);
            //TreeNode ascTree = MinimalBSTFromArr(ascArr, true);
            //TreeNode dscTree = MinimalBSTFromArr(dscArr, false);

            //Soln. 4-2:
            //var graph = CreateNewGraph();
            //var nodes = graph.Nodes;
            //var start = nodes[0];
            //var end = nodes[8];
            //Console.WriteLine(FindPathInGraph(graph, start, end, false));
            //ResetVisitStatus(graph);
            //Console.WriteLine(FindPathInGraph(graph, start, end, true));

            ////Soln. 4-1:
            //// Create balanced tree
            //int[] array = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            //var root = TreeNode.CreateMinimalBst(array);
            //Console.WriteLine("Root? " + root.Data);            
            //Console.WriteLine("Is balanced? " + IsBalanced(root));
            //// Could be balanced, actually, but it's very unlikely...
            //var unbalanced = new TreeNode(10);
            //Random random = new Random();
            //for (var i = 0; i < 10; i++)
            //{
            //    unbalanced.InsertInOrder(random.Next(0, 100));
            //}
            //Console.WriteLine("Root? " + unbalanced.Data);
            //Console.WriteLine("Is balanced? " + IsBalanced(unbalanced));

            //Soln. 3-7:
            //var animals = new AnimalQueue();
            //animals.Enqueue(new Cat("Callie"));
            //animals.Enqueue(new Cat("Kiki"));
            //animals.Enqueue(new Dog("Fido"));
            //animals.Enqueue(new Dog("Dora"));
            //animals.Enqueue(new Cat("Kari"));
            //animals.Enqueue(new Dog("Dexter"));
            //animals.Enqueue(new Dog("Dobo"));
            //animals.Enqueue(new Cat("Copa"));
            //Console.WriteLine("Peek a dog and cat:");
            //Console.WriteLine(animals.PeekDogs().GetName());
            //Console.WriteLine(animals.PeekCats().GetName());
            //Console.WriteLine();
            //Console.WriteLine(animals.DequeueAny().GetName());
            //Console.WriteLine(animals.DequeueAny().GetName());
            //Console.WriteLine(animals.DequeueAny().GetName());
            //animals.Enqueue(new Dog("Dapa"));
            //animals.Enqueue(new Cat("Kilo"));
            //while (animals.Count() != 0)
            //{
            //    Console.WriteLine(animals.DequeueAny().GetName());
            //}

            //Soln. 3-6:
            //Stack<int> stack = new Stack<int>();
            //Random rand = new Random(10);

            //for (int counter = 0; counter < 12; counter++)
            //{
            //    stack.Push(rand.Next(5, 50));
            //}

            ////var sorted = SortStack(stack);

            //var sorted2 = MergeSortStack(stack);


            ////Soln. 3-5:
            //var myQueue = new MyQueue<int>();

            //// Let's test our code against a "real" queue
            //var testQueue = new Queue<int>();

            //var rand = new Random(2);

            //for (var i = 0; i < 100; i++)
            //{
            //    var choice = rand.Next(1, 10);

            //    if (choice <= 5)
            //    {
            //        // enqueue
            //        var element = rand.Next(1, 10);
            //        testQueue.Enqueue(element);
            //        myQueue.Enqueue(element);
            //        Console.WriteLine("Enqueued " + element);
            //    }
            //    else if (testQueue.Count > 0)
            //    {
            //        var top1 = testQueue.Dequeue();
            //        var top2 = myQueue.Dequeue();

            //        if (top1 != top2)
            //        { // Check for error
            //            Console.WriteLine("******* FAILURE - DIFFERENT TOPS: " + top1 + ", " + top2);
            //        }
            //        Console.WriteLine("Dequeued " + top1);
            //    }

            //    if (testQueue.Count == myQueue.Count())
            //    {
            //        if (testQueue.Count > 0 && testQueue.Peek() != myQueue.Peek())
            //        {
            //            Console.WriteLine("******* FAILURE - DIFFERENT TOPS: " + testQueue.Peek() + ", " + myQueue.Peek() + " ******");
            //        }
            //    }
            //    else
            //    {
            //        Console.WriteLine("******* FAILURE - DIFFERENT SIZES ******");
            //    }
            //}

            //Soln1-1:
            //CheckUniqueSoln();

            //Sol 1-2:
            //Console.WriteLine(Reverse("demo 123 string."));

            //Problem 17-7:
            //long val = 1234567890;
            //Console.WriteLine("Number: {0}", val);
            //Console.WriteLine("Phrase: {0}", NumToPhrase(val));

            //Triplets
            //double[] array = new double[] { 20, 11, 5, 3, 7, 5, 6, 4, 8, 2, 1, 11, 26, 10, 24 };
            //FindTripletsType01(array);

            //Solution 1-3: Replace chars in place
            //char[] testData = new char[100];
            //"Testdata data test testda ta testd ata data test.".ToCharArray().CopyTo(testData, 0);
            //Console.WriteLine(ReplaceInplaceChars(testData, ' ', "&20".ToCharArray(), 49));

            //Compress string
            //var testdata = "aaabbbbccddddddeeffffffffffffffffffffff";
            //var testdata = "AABBCCDDEEFF";
            //var testdata = File.ReadAllText(@"\\scratch2\scratch\v-sandis\configs\IB1xsmb_ServiceConfiguration.cscfg");
            //Console.WriteLine("Origibal: {1},  Compressed: {0}", Compressstring(testdata.ToCharArray()), testdata);

            //Rotate matrix
            /*
            int[,] matrix = new int[15,10];

            for (int counter1 = 0; counter1 < 15; counter1++)
            {
                for (int counter2 = 0; counter2 < 10; counter2++)
                {
                    matrix[counter1, counter2] = Convert.ToInt32(string.Format("{0}{1}", counter1, counter2));
                }
            }

            Console.WriteLine("Orinal:");
            for (int i = 0; i < 15; i++)
            {
                Console.WriteLine();
                for (int j = 0; j < 10; j++)
                {
                    Console.Write("{0}  ", matrix[i, j]);
                }
            }
            Console.WriteLine();

            int[,] m2 = RotateMatrix2(matrix, 15, 10);

            Console.WriteLine("Rotated:");
            for (int i = 0; i < 10; i++)
            {
                Console.WriteLine();
                for (int j = 0; j < 15; j++)
                {
                    Console.Write("{0}  ", m2[i, j]);
                }
            }
            Console.WriteLine();
            */


            ////Soln, 1-last:
            //string s1 = "waterbottle";
            //string s2 = "bottleawter";
            //var temp = IsRotation(s1, s2);

            //Soln. 2-1:
            //DeleteDups(list1);

            //Soln. 2-2:
            //var k = NthToLast(list1, 5);

            //Soln. 2-3:
            //var h2 = SortLinkedList(list1);
            //PrintVertical(1234);
            //MakeTheNumbersMatch(5, 3, 8, 9);

            //Soln. 2-4:
            //var l2 = Partition(list1, 7);

            //AMZ phone-prob
            //int[] ip1 = new int[] { 1, 2, 3, 4 };
            //int[] ip2 = new int[] { 1, 2, 9, 9 };
            //int[] ip3 = new int[] { 9, 9, 9, 9 };
            //int[] r1 = AddOne(ip1);
            //int[] r2 = AddOne(ip2);
            //int[] r3 = AddOne(ip3);

            //Soln. 2-5:
            //Console.WriteLine(list1.PrintForward());
            //Console.WriteLine(list2.PrintForward());
            //Console.WriteLine("");
            //var l2 = GetSum(list1, list1, true);
            //var l3 = GetSum(list2, list2, false);
            //Console.WriteLine(l2.PrintForward());
            //Console.WriteLine(l3.PrintForward());

            ////Soln. 2-6:
            ////Create list
            //var list1 = new LinkedListNode[15];

            //for (var i = 1; i <= 15; i++)
            //{
            //    list1[i - 1] = new LinkedListNode(i, null, i - 1 > 0 ? list1[i - 2] : null);
            //    Console.Write("{0} . ", list1[i - 1].Data);
            //}

            //// Create loop
            //list1[GetListLength(list1[0]) - 1].Next = list1[5];
            //var loop = FindCircularHead(list1[0]);
            //Console.WriteLine(list1[0].PrintForward());


            //Soln. 2-7:
            /*
            var temp = list2;
            for (int counter = 0; counter < (int)GetListLength(list2); counter++)
            {
                if (counter % 2 == 0)
                {
                    temp.Data = 1;
                }
                else
                {
                    temp.Data = 6;
                }
                temp = temp.Next;
            }

            var r1 = IsListPalindrome(list1);
            var r2 = IsListPalindromeNonRecursive(list2);
            var l2 = ReverseListRecurse(list1);
            */

            //General Linked lIst sample data generation
            /*
            var first = new LinkedListNode(5, null, null);
            var originalList = first;
            var second = first;

            for (var counter = 0; counter < 8; counter++)
            {
                second = new LinkedListNode(9 - counter, null, null);
                first.SetNext(second);
                second.SetPrevious(first);
                first = second;
            }

            var list1 = originalList.Clone();
            var list2 = originalList.Clone();
            */

            /*Soln. 3-1:
            Console.WriteLine("IsEmpty stack 0? {0}", IsEmpty(0));

            Push(0, 10);
            Push(1, 20);
            Push(2, 30);

            Push(0, 12);
            Push(1, 22);
            Push(2, 32);

            Push(0, 13);
            Push(1, 23);
            Push(2, 33);

            Push(0, 14);
            Push(1, 24);
            Push(2, 34);

            Push(0, 15);
            Push(1, 25);
            Push(2, 35);

            Push(1, 21);
            Push(0, 11);
            Push(0, 12);

            var popped = Pop(0);
            Console.WriteLine("popped: {0}", popped);
            Console.WriteLine();

            Push(2, 36);
            Push(0, 16);
            Push(1, 26);

            Push(2, 40);
            Push(2, 41);
            Push(2, 42);
            Push(2, 43);

            Push(2, 47);
            Push(2, 46);
            Push(2, 45);
            Push(2, 44);

            popped = Pop(1);
            Console.WriteLine("popped: {0}", popped);
            */

            //Soln. 3-2:
            /*
            StackWithMin minStack = new StackWithMin(911);
            Random randomInt = new Random(100);            
            for (int counter = 0; counter < 10; counter++)
            {
                minStack.Push(randomInt.Next(999));
            }
            for (int counter = 0; counter < 11; counter++)
            {
                var min = minStack.Min();
                Console.WriteLine("Value: {0},  Min: {1}", minStack.Pop(), min);
            }
            */

            //Soln. 3-3:
            //const int capacityPerSubstack = 5;
            //var set = new SetOfStacks(capacityPerSubstack);

            //Console.WriteLine("IsEmpty? {0}", set.IsEmpty());

            //for (var i = 0; i < 36; i++)
            //{
            //    set.Push(i);
            //}
            //Console.WriteLine("IsEmpty? {0}", set.IsEmpty());

            //for (var i = 0; i < 36; i++)
            //{
            //    Console.WriteLine("Popped " + set.PopAt(i % set.Count()));
            //}

            // Set up code.
            //const int n = 5;
            //var towers = new Tower[3];

            //for (var i = 0; i < 3; i++)
            //{
            //    towers[i] = new Tower(i);
            //    towers[i].Label = string.Format("{0}", i); ;
            //}

            //for (var i = n - 1; i >= 0; i--)
            //{
            //    towers[0].Add(i);
            //}

            //towers[0].Print();
            //towers[1].Print();
            //towers[2].Print();
            //Console.WriteLine();
            //towers[0].MoveDisks(n, towers[2], towers[1]);
            //Console.WriteLine();
            //towers[0].Print();
            //towers[1].Print();
            //towers[2].Print();

            /*
            //Insertion Sort
            var rand = new Random(50);
            int[] iparr = new int[10];
            for (int index1 = 0; index1 < 10; index1++)
            {
                iparr[index1] = rand.Next(int.MaxValue - 1);
            }

            int[] inserttionSort = new int[10];
            iparr.CopyTo(inserttionSort, 0);
            InserttionSort(inserttionSort);

            int[] mergeSort = new int[10];
            iparr.CopyTo(mergeSort, 0);
            MergeSort(inserttionSort);

            int[] quickSort = new int[10];
            iparr.CopyTo(quickSort, 0);
            QuickSort(inserttionSort);

            Console.WriteLine();
            
            int test = FindMatch("sandip", "sinhasandipsinha");
            
            //BellmanFord Problem
            int V = 5;  // Number of vertices in graph
            int E = 8;  // Number of edges in graph

            Graph4BF graph = new Graph4BF(V, E);

            // add edge 0-1 (or A-B in above figure)
            graph.edge[0].src = 0;
            graph.edge[0].dest = 1;
            graph.edge[0].weight = -1;

            // add edge 0-2 (or A-C in above figure)
            graph.edge[1].src = 0;
            graph.edge[1].dest = 2;
            graph.edge[1].weight = 4;

            // add edge 1-2 (or B-C in above figure)
            graph.edge[2].src = 1;
            graph.edge[2].dest = 2;
            graph.edge[2].weight = 3;

            // add edge 1-3 (or B-D in above figure)
            graph.edge[3].src = 1;
            graph.edge[3].dest = 3;
            graph.edge[3].weight = 2;

            // add edge 1-4 (or A-E in above figure)
            graph.edge[4].src = 1;
            graph.edge[4].dest = 4;
            graph.edge[4].weight = 2;

            // add edge 3-2 (or D-C in above figure)
            graph.edge[5].src = 3;
            graph.edge[5].dest = 2;
            graph.edge[5].weight = 5;

            // add edge 3-1 (or D-B in above figure)
            graph.edge[6].src = 3;
            graph.edge[6].dest = 1;
            graph.edge[6].weight = 1;

            // add edge 4-3 (or E-D in above figure)
            graph.edge[7].src = 4;
            graph.edge[7].dest = 3;
            graph.edge[7].weight = -3;

            graph.BellmanFord(graph, 0);
            */

            #endregion





            Console.ReadLine();
        }

        #region HashTable
        /*
        public struct KeyValue<K, V> 
            where K : IComparable
        {
            public K Key { get; set; }
            public V Value { get; set; }
        }

        public class FixedSizeGenericHashTable<K, V>
            where K : IComparable
        {
            private readonly int size;
            private readonly BinaryTree<KeyValue<K, V>>[] items;

            public FixedSizeGenericHashTable(int size)
            {
                this.size = size;
                items = new BinaryTree<KeyValue<K, V>>[size];
            }

            protected int GetArrayPosition(K key)
            {
                int position = key.GetHashCode() % size;
                return Math.Abs(position);
            }

            public V Find(K key)
            {
                int position = GetArrayPosition(key);
                BinaryTree<KeyValue<K, V>> linkedList = GetLinkedList(position);
                var result = Find(key, linkedList);
                if (null == result)
                {
                    return default(V);
                }

                return result;
            }

            private V Find(K key, BinaryTree<KeyValue<K, V>> tree)
            {
                if (null == key || null == tree)
                {
                    return null;
                }
                else
                {
                    if (key.CompareTo(tree.k)
                    {

                    }
                }
            }

            public void Add(K key, V value)
            {
                int position = GetArrayPosition(key);
                BinaryTree<KeyValue<K, V>> linkedList = GetLinkedList(position);
                KeyValue<K, V> item = new KeyValue<K, V>() { Key = key, Value = value };
                linkedList.AddLast(item);
            }

            public void Remove(K key)
            {
                int position = GetArrayPosition(key);
                BinaryTree<KeyValue<K, V>> linkedList = GetLinkedList(position);
                bool itemFound = false;
                KeyValue<K, V> foundItem = default(KeyValue<K, V>);
                foreach (KeyValue<K, V> item in linkedList)
                {
                    if (item.Key.Equals(key))
                    {
                        itemFound = true;
                        foundItem = item;
                    }
                }

                if (itemFound)
                {
                    linkedList.Remove(foundItem);
                }
            }

            protected BinaryTree<KeyValue<K, V>> GetLinkedList(int position)
            {
                BinaryTree<KeyValue<K, V>> linkedList = items[position];
                if (linkedList == null)
                {
                    linkedList = new BinaryTree<KeyValue<K, V>>();
                    items[position] = linkedList;
                }

                return linkedList;
            }
        }
        */
        #endregion

        

        #region LRU Cache

        // A Queue (A FIFO collection of Queue Nodes)
        internal class LRUCache
        {
            // A Queue Node (Queue is implemented using Doubly Linked List)
            internal class Node
            {
                internal Node prev, next;
                internal uint pageNumber;  // the page number stored in this QNode

                // A utility function to create a new Queue Node. The queue Node
                // will store the given 'pageNumber'
                public static Node NewNode(uint pageNumber)
                {
                    // Allocate memory and assign 'pageNumber'
                    Node temp = new Node();
                    temp.pageNumber = pageNumber;

                    // Initialize prev and next as null
                    temp.prev = temp.next = null;

                    return temp;
                }
            }

            // A hash (Collection of pointers to Queue Nodes)
            public class PageFrame
            {
                internal uint capacity; // how many pages can be there
                internal Node[] array; // an array of queue nodes

                // A utility function to create an empty Hash of given capacity
                public static PageFrame CreatePageFrame(uint capacity)
                {
                    // Allocate memory for hash
                    PageFrame hash = new PageFrame();
                    hash.capacity = capacity;

                    // Create an array of pointers for refering queue nodes
                    hash.array = new Node[capacity];

                    // Initialize all hash entries as empty                
                    for (int index = 0; index < hash.capacity; index++)
                        hash.array[index] = null;

                    return hash;
                }
            }

            internal uint count;  // Number of filled frames
            internal uint numberOfFrames; // total number of frames
            internal Node front, rear;           

            // A utility function to create an empty Queue.
            // The queue can have at most 'numberOfFrames' nodes
            public static LRUCache CreateLRUCache(uint numberOfFrames)
            {
                LRUCache queue = new LRUCache();

                // The queue is empty
                queue.count = 0;
                queue.front = queue.rear = null;

                // Number of frames that can be stored in memory
                queue.numberOfFrames = numberOfFrames;

                return queue;
            }           

            // A function to check if there is slot available in memory
            public bool AreAllFramesFull(LRUCache queue)
            {
                return queue.count == queue.numberOfFrames;
            }

            // A utility function to check if queue is empty
            public bool IsCacheEmpty(LRUCache queue)
            {
                return queue.rear == null;
            }

            // A utility function to delete a frame from queue
            public void RemoveFromCache(LRUCache queue)
            {
                if (IsCacheEmpty(queue))
                    return;

                // If this is the only node in list, then change front
                if (queue.front == queue.rear)
                    queue.front = null;

                // Change rear and remove the previous rear
                Node temp = queue.rear;
                queue.rear = queue.rear.prev;

                if (null != queue.rear)
                    queue.rear.next = null;

                // decrement the number of full frames by 1
                queue.count--;
            }

            // A function to add a page with given 'pageNumber' to both queue
            // and hash
            public void AddToCache(LRUCache queue, PageFrame hash, uint pageNumber)
            {
                // If all frames are full, remove the page at the rear
                if (AreAllFramesFull(queue))
                {
                    // remove page from hash
                    hash.array[queue.rear.pageNumber] = null;
                    RemoveFromCache(queue);
                }

                // Create a new node with given page number,
                // And add the new node to the front of queue
                Node temp = Node.NewNode(pageNumber);
                temp.next = queue.front;

                // If queue is empty, change both front and rear pointers
                if (IsCacheEmpty(queue))
                    queue.rear = queue.front = temp;
                else  // Else change the front
                {
                    queue.front.prev = temp;
                    queue.front = temp;
                }

                // Add page entry to hash also
                hash.array[pageNumber] = temp;

                // increment number of full frames
                queue.count++;
            }

            // This function is called when a page with given 'pageNumber' is referenced
            // from cache (or memory). There are two cases:
            // 1. Frame is not there in memory, we bring it in memory and add to the front
            //    of queue
            // 2. Frame is there in memory, we move the frame to front of queue
            public void ReferencePage(LRUCache queue, PageFrame hash, uint pageNumber)
            {
                Node reqPage = hash.array[pageNumber];

                // the page is not in cache, bring it
                if (reqPage == null)
                    AddToCache(queue, hash, pageNumber);

                // page is there and not at front, change pointer
                else if (reqPage != queue.front)
                {
                    // Unlink rquested page from its current location
                    // in queue.
                    reqPage.prev.next = reqPage.next;
                    if (null != reqPage.next)
                        reqPage.next.prev = reqPage.prev;

                    // If the requested page is rear, then change rear
                    // as this node will be moved to front
                    if (reqPage == queue.rear)
                    {
                        queue.rear = reqPage.prev;
                        queue.rear.next = null;
                    }

                    // Put the requested page before current front
                    reqPage.next = queue.front;
                    reqPage.prev = null;

                    // Change prev of current front
                    reqPage.next.prev = reqPage;

                    // Change front to the requested page
                    queue.front = reqPage;
                }
            }
        }

        #endregion

        #region PetrolPump

        private static int StartTour(int[,] pumps)
        {
            //err check
            if (null == pumps || pumps.Length == 0)
            {
                return -1;
            }
            else
            {
                int start = 0, end = 1, currFuel = pumps[0, 0] - pumps[0, 1], length = pumps.Length / 2;


                //traverse till all pumps are visited and reached 1st one with 0+ fuel
                while (start != end || currFuel < 0)
                {
                    //if current fuel is less than 0 then remove starting pump
                    while (start != end && currFuel < 0)
                    {
                        // Remove starting petrol pump. Change start
                        currFuel -= pumps[start, 0] - pumps[start, 1];
                        start = (start + 1) % length;

                        // If 0 is being considered as start again, then there is no
                        // possible solution
                        if (start == 0)
                            return -1;
                    }

                    // Add a petrol pump to current tour
                    currFuel += pumps[end, 0] - pumps[end, 1];

                    end = (end + 1) % length;
                }

                //return starting point
                return start;
            }
        }

        #endregion

        #region Test
        private class RunningNumber
        {
            private static double lastAvg = 0.0;
            private static long lastTotalCount = 0;
            internal static double Avg(int index)
            {
                lastTotalCount++;

                if (lastTotalCount == 1)
                {
                    lastAvg = index;
                }
                else
                {
                    var p1 = (double)(lastAvg / lastTotalCount);
                    var p2 = (double)((double)(lastTotalCount - 1) / lastTotalCount);
                    var p3 = (double)((double)index / lastTotalCount);
                    lastAvg = ((p1 * p2) + p3);
                }

                return lastAvg;
            }
        }

        public static TreeNode BuildTree(int[] inorder, int[] postorder)
        {
            int inStart = 0;
            int inEnd = inorder.Length - 1;
            int postStart = 0;
            int postEnd = postorder.Length - 1;

            return buildTree(inorder, inStart, inEnd, postorder, postStart, postEnd);
        }

        private static TreeNode buildTree(int[] inorder, int inStart, int inEnd,
                int[] postorder, int postStart, int postEnd)
        {
            if (inStart > inEnd || postStart > postEnd)
                return null;

            int rootValue = postorder[postEnd];
            TreeNode root = new TreeNode(rootValue);

            int inOrderRootIndex = 0;
            for (int index = 0; index < inorder.Length; index++)
            {
                if (inorder[index] == rootValue)
                {
                    inOrderRootIndex = index;
                    break;
                }
            }

            root.Left = buildTree(inorder, inStart, inOrderRootIndex - 1, postorder, postStart,
                    postStart + inOrderRootIndex - (inStart + 1));
            // Becuase k is not the length, it it need to -(inStart+1) to get the length
            root.Right = buildTree(inorder, inOrderRootIndex + 1, inEnd, postorder, postStart + inOrderRootIndex - inStart, postEnd - 1);
            // postStart+k-inStart = postStart+k-(inStart+1) +1

            return root;
        }


        public static bool IsPathExists(TreeNode root, int sum, out List<int> numbers)
        {
            if (root == null)
            {
                numbers = null;
                return false;
            }
            else
            {
                List<int> tempList = new List<int>();
                var op = IsPathExistRecurse(root, sum, ref tempList);
                numbers = tempList;
                return op;
            }
        }

        private static bool IsPathExistRecurse(TreeNode root, int sum, ref List<int> numbers)
        {
            if (root == null)
            {
                return false;
            }
            else
            {
                numbers.Add(root.Data);

                if (root.Data == sum && (root.Left == null && root.Right == null))
                    return true;
                else
                {
                    if (IsPathExistRecurse(root.Left, sum - root.Data, ref numbers))
                    {
                        return true;
                    }
                    else if (null != root.Left && numbers.Contains(root.Left.Data))
                    {
                        numbers.Remove(root.Left.Data);
                    }

                    if (IsPathExistRecurse(root.Right, sum - root.Data, ref numbers))
                    {
                        return true;
                    }
                    else if (null != root.Right && numbers.Contains(root.Right.Data))
                    {
                        numbers.Remove(root.Right.Data);
                    }
                }

                return false;
            }
        }

        #endregion

        #region LCA

        private static TreeNode FindLCAUtil(TreeNode node, int num1, int num2, ref bool isNum1Found, ref bool isNum2Found)
        {
            // Base case
            if (node == null)
                return null;

            // If either n1 or n2 matches with root's key, report the presence
            // by setting v1 or v2 as true and return root (Note that if a key
            // is ancestor of other, then the ancestor key becomes LCA)
            if (node.Data == num1)
            {
                isNum1Found = true;
                return node;
            }
            if (node.Data == num2)
            {
                isNum2Found = true;
                return node;
            }

            // Look for keys in left and right subtrees
            TreeNode leftLCA = FindLCAUtil(node.Left, num1, num2, ref isNum1Found, ref isNum2Found);
            TreeNode rightLCA = FindLCAUtil(node.Right, num1, num2, ref isNum1Found, ref isNum2Found);

            // If both of the above calls return Non-null, then one key
            // is present in once subtree and other is present in other,
            // So this node is the LCA
            if (leftLCA != null && rightLCA != null)
                return node;

            // Otherwise check if left subtree or right subtree is LCA
            return (leftLCA != null) ? leftLCA : rightLCA;
        }

        // Finds lca of n1 and n2 under the subtree rooted with 'node'
        private static TreeNode findLCA(TreeNode root, int num1, int num2)
        {
            // Initialize n1 and n2 as not visited
            bool isNum1Found = false;
            bool isNum2Found = false;

            // Find lca of n1 and n2 using the technique discussed above
            TreeNode lca = FindLCAUtil(root, num1, num2, ref isNum1Found, ref isNum2Found);

            // Return LCA only if both n1 and n2 are present in tree
            if (isNum1Found && isNum2Found)
                return lca;

            // Else return null
            return null;
        }

        #endregion

        #region VerticalSum

        private static DoublyLinkedList GetVerticalSums(TreeNode root)
        {
            //error check
            if (null == root)
            {
                throw new Exception("Invalid input.");  //create custom or appropiate exception
            }
            else
            {
                DoublyLinkedList list = new DoublyLinkedList();

                //Get the list populated with vertical sums
                GetVerticalSums(root, list);

                //go to begining of the list before returning
                while (list.Prev != null)
                {
                    list = list.Prev;
                }

                return list;
            }
        }

        private static void GetVerticalSums(TreeNode root, DoublyLinkedList list)
        {
            //add root's Data to list's sum
            list.Sum += root.Data;

            //check left sub tree and calculate it's sum
            if (root.Left != null)
            {
                //create previous list node if doesn't exists
                if (list.Prev == null)
                {
                    list.Prev = new DoublyLinkedList();
                    list.Prev.Next = list;
                }

                //Calculate sum for the left tree node and store it in prev list node
                GetVerticalSums(root.Left, list.Prev);
            }

            //check right sub tree and calculate it's sum
            if (root.Right != null)
            {
                //create next list node if doesn't exists
                if (list.Next == null)
                {
                    list.Next = new DoublyLinkedList();
                    list.Next.Prev = list;
                }

                //Calculate sum for the right tree node and store it in next list node
                GetVerticalSums(root.Right, list.Next);
            }

        }

        private class DoublyLinkedList
        {
            public int Sum;
            public DoublyLinkedList Next, Prev;

            public DoublyLinkedList()
            {
                Sum = 0;
                Next = null;
                Prev = null;
            }
        }

        #endregion

        #region Ancestor Matrix from Tree

        // anc[] stores all ancestors of current node.  This
        // function fills ancestors for all nodes.
        // It also returns size of tree.  Size of tree is
        // used to print ancestor matrix.
        private static int AncestorMatrixRec(TreeNode root, List<int> ancestor, ref bool[,] matrix)
        {
            /* base case */
            if (root == null) return 0;

            // Update all ancestors of current node
            int data = root.Data;
            for (int index = 0; index < ancestor.Count; index++)
                matrix[ancestor[index], data] = true;

            // Push data to list of ancestors
            ancestor.Add(data);

            // Traverse left and right subtrees
            int left = AncestorMatrixRec(root.Left, ancestor, ref matrix);
            int right = AncestorMatrixRec(root.Right, ancestor, ref matrix);

            // Remove data from list the list of ancestors
            // as all descendants of it are processed now.
            ancestor.RemoveAt(ancestor.Count - 1);

            return left + right + 1;
        }

        // This function mainly calls ancestorMatrixRec()
        private static bool[,] ancestorMatrix(TreeNode root)
        {
            //height of tree
            int height = root.GetTreeSize();

            // Create an empty ancestor array
            List<int> ancestor = new List<int>();

            // Creating a boolean matrix
            bool[,] matrix = new bool[height, height];

            // Fill ancestor matrix and find size of
            // tree.
            int size = AncestorMatrixRec(root, ancestor, ref matrix);

            // Print the filled values
            for (int index1 = 0; index1 < size; index1++)
            {
                for (int index2 = 0; index2 < size; index2++)
                    Console.Write(matrix[index1, index2] + " ");

                Console.WriteLine();
            }

            return matrix;
        }

        #endregion

        #region Tree from ancestor matrix

        // Constructs tree from ancestor matrix
        private static TreeNode AncestorTree(int[,] matrix)
        {
            int length = (int)Math.Sqrt(matrix.Length);

            // Binary array to determine weather
            // parent is set for node i or not
            bool[] parent = new bool[length];

            // Root will store the root of the constructed tree
            TreeNode root = null;

            // node[i] will store node for i in constructed tree
            TreeNode[] nodes = new TreeNode[length];

            // Create a multimap, sum is used as key and row
            // numbers are used as values
            List<KeyValuePair<int, int>> map = new List<KeyValuePair<int, int>>();

            for (int index1 = 0; index1 < length; index1++)
            {
                int sum = 0; // Initialize sum of this row
                for (int index2 = 0; index2 < length; index2++)
                    sum += matrix[index1, index2];

                // insert(sum, i) pairs into the multimap
                map.Add(new KeyValuePair<int, int>(sum, index1));

                // create a new node for every value
                nodes[index1] = new TreeNode(index1);
            }

            // Traverse all entries of multimap.  Note that values
            // are accessed in increasing order of sum
            foreach (var item in map)
            {
                // To store last processed node. This node will be
                // root after loop terminates
                root = nodes[item.Value];

                // if non-leaf node
                if (item.Key != 0)
                {
                    // traverse row 'it.second' in the matrix
                    for (int index1 = 0; index1 < length; index1++)
                    {
                        // if parent is not set and ancestor exits
                        if (!parent[index1] && matrix[item.Value, index1] == 1)
                        {
                            // check for unoccupied left/right node
                            // and set parent of node i
                            if (nodes[item.Value].Left == null)
                                nodes[item.Value].Left = nodes[index1];
                            else
                                nodes[item.Value].Right = nodes[index1];

                            parent[index1] = true;
                        }
                    }
                }
            }
            return root;
        }

        /* Given a binary tree, print its nodes in inorder */
        private static void PrintInorder(TreeNode node)
        {
            if (node == null)
                return;
            PrintInorder(node.Left);
            Console.Write(node.Data + " ");
            PrintInorder(node.Right);
        }

        #endregion

        /*
        public ArrayList<ArrayList<Integer>> permute(int[] num)
        {
            ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
            permute(num, 0, result);
            return result;
        }

        void permute(int[] num, int start, ArrayList<ArrayList<Integer>> result)
        {

            if (start >= num.length)
            {
                ArrayList<Integer> item = convertArrayToList(num);
                result.add(item);
            }

            for (int j = start; j <= num.length - 1; j++)
            {
                swap(num, start, j);
                permute(num, start + 1, result);
                swap(num, start, j);
            }
        }

        private ArrayList<Integer> convertArrayToList(int[] num)
        {
            ArrayList<Integer> item = new ArrayList<Integer>();
            for (int h = 0; h < num.length; h++)
            {
                item.add(num[h]);
            }
            return item;
        }

        private void swap(int[] a, int i, int j)
        {
            int temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        }*/

        #region trie

        private class TrieNode
        {
            public string Key = string.Empty;
            public Dictionary<string, TrieNode> children = new Dictionary<string, TrieNode>();
            public int Value = 0;

            internal void Insert(List<string> list, int value)
            {
                //error check
                if (list.Count < 1)
                {
                    return;
                }
                else
                {
                    Dictionary<string, TrieNode> tempChildren = this.children;

                    for (int index = 0; index < list.Count; index++)
                    {
                        string current = list[index];

                        TrieNode node;
                        //if key is there, get it to next node
                        if (tempChildren.ContainsKey(current))
                        {
                            node = tempChildren[current];
                        }
                        //if key is not present, add a new child node
                        else
                        {
                            node = new TrieNode();
                            node.Key = current;
                            tempChildren.Add(node.Key, node);
                        }

                        tempChildren = node.children;

                        //if leaf, set the value
                        if (index == list.Count - 1)
                        {
                            node.Value = value;
                        }
                    }
                }
            }

            internal bool Search(List<string> list)
            {
                return Search(list, 0, children);
            }

            private bool Search(List<string> list, int index, Dictionary<string, TrieNode> children)
            {
                //error check
                if (list.Count < 1)
                {
                    return false;
                }
                else if (index == list.Count)
                {
                    //if index is at last element in listand it has no children
                    //then we have found the exact pattern
                    if (children.Count == 0)
                    {
                        return true;
                    }
                    //if we still have children, then it's not an exact match
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    string current = list[index];

                    //check if current key is there in childrens
                    if (children.ContainsKey(current))
                    {
                        //if last element, return true
                        if (index == list.Count - 1)
                        {
                            return true;
                        }
                        //else go to next element in list
                        else
                        {
                            return Search(list, index + 1, children[current].children);
                        }
                    }
                    //check for "." as it might point to new branch
                    else if (current.Equals(".", StringComparison.OrdinalIgnoreCase))
                    {
                        bool result = false;

                        //for "." check with all children
                        foreach (var child in children)
                        {
                            //if last element, return true
                            if (index == list.Count - 1)
                            {
                                return true;
                            }
                            //else go to next element in list
                            else if (Search(list, index + 1, child.Value.children))
                            {
                                result = true;
                            }
                        }

                        return result;
                    }
                    //if nothing matches any more, return false
                    else
                        return false;
                }
            }
        }

        #endregion

        #region FractionToDecimal

        private static string FractionToDecimal(int numerator, int denominator)
        {
            if (numerator == 0)
                return "0";
            if (denominator == 0)
                return "";

            string result = "";

            // is result is negative
            if ((numerator < 0) ^ (denominator < 0))
            {
                result += "-";
            }

            // convert int to long
            long num = numerator, den = denominator;
            num = Math.Abs(num);
            den = Math.Abs(den);

            // quotient 
            long res = num / den;
            result += string.Format("{0}", res);

            // if remainder is 0, return result
            long remainder = (num % den) * 10;
            if (remainder == 0)
                return result;

            // right-hand side of decimal point
            Dictionary<long, int> map = new Dictionary<long, int>();
            result += ".";
            while (remainder != 0)
            {
                // if digits repeat
                if (map.ContainsKey(remainder))
                {
                    int beg = map[remainder];
                    string part1 = result.Substring(0, beg - 0);
                    string part2 = result.Substring(beg, result.Length - beg);
                    result = part1 + "(" + part2 + ")";
                    return result;
                }

                // continue
                map[remainder] = result.Length;
                res = remainder / den;
                result += string.Format("{0}", res);
                remainder = (remainder % den) * 10;
            }

            return result;
        }

        #endregion

        #region Reverse String without special chars

        private static char[] SpecialReverse(char[] input)
        {
            //err check
            if (null == input || input.Length == 0)
            {
                throw new Exception("Input is empty, nothing to reverse");
            }
            else
            {
                int start = 0, end = input.Length - 1;

                //traverse till mid and swap if alphabet
                while (start < end)
                {
                    if (!char.IsLetter(input[start]))
                    {
                        start++;
                    }
                    else if (!char.IsLetter(input[end]))
                    {
                        end--;
                    }
                    else
                    {
                        char ch = input[start];
                        input[start] = input[end];
                        input[end] = ch;

                        end--;
                        start++;
                    }
                }

                return input;
            }
        }

        #endregion

        #region Palindrome Partitioning

        // Returns the minimum number of cuts needed to partition a string
        // such that every part is a palindrome
        private static int MinPalindromePartion(string str)
        {
            // Get the length of the string
            int length = str.Length;

            /* Create two arrays to build the solution in bottom up manner
               count[i] = Minimum number of cuts needed for palindrome partitioning
                         of substring str[0..i]
               P[i][j] = true if substring str[i..j] is palindrome, else false
               Note that count[i] is 0 if flags[0][i] is true */
            int[] count = new int[length];
            bool[,] flags = new bool[length, length];

            // Every substring of length 1 is a palindrome
            for (int index = 0; index < length; index++)
            {
                flags[index, index] = true;
            }

            /* index4 is substring length. Build the solution in bottom up manner by
               considering all substrings of length starting from 2 to length. */
            for (int index1 = 2; index1 <= length; index1++)
            {
                // For substring of length L, set different possible starting indexes
                for (int index2 = 0; index2 < length - index1 + 1; index2++)
                {
                    int tempIndex = index2 + index1 - 1; // Set ending index

                    // If L is 2, then we just need to compare two characters. Else
                    // need to check two corner characters and value of P[i+1][j-1]
                    if (index1 == 2)
                        flags[index2, tempIndex] = (str[index2] == str[tempIndex]);
                    else
                        flags[index2, tempIndex] = (str[index2] == str[tempIndex]) && flags[index2 + 1, tempIndex - 1];
                }
            }

            for (int index1 = 0; index1 < length; index1++)
            {
                if (flags[0, index1] == true)
                    count[index1] = 0;
                else
                {
                    count[index1] = int.MaxValue;
                    for (int index2 = 0; index2 < index1; index2++)
                    {
                        if (flags[index2 + 1, index1] == true && 1 + count[index2] < count[index1])
                            count[index1] = 1 + count[index2];
                    }
                }
            }

            // Return the min cut value for complete string. i.e., str[0..n-1]
            return count[length - 1];
        }

        #endregion

        #region Isomorphic

        private static bool AreIsomorphic(string str1, string str2)
        {
            //err check
            if (string.IsNullOrEmpty(str1) || string.IsNullOrEmpty(str2))
            {
                throw new Exception("null or empty string is not allowed");
            }
            else if (str1.Length != str2.Length)
            {
                return false;
            }
            else
            {
                //check str1 and find indexes of all characters
                Dictionary<char, List<int>> charCount01 = new Dictionary<char, List<int>>();

                for (int index = 0; index < str1.Length; index++)
                {
                    if (charCount01.ContainsKey(str1[index]))
                    {
                        charCount01[str1[index]].Add(index);
                    }
                    else
                    {
                        charCount01.Add(str1[index], new List<int>() { index });
                    }
                }

                //check str2 and match characters at the indexes
                foreach (var pair in charCount01)
                {
                    //fetch the correspong char in str2 mapping to the char in str1 at the same index
                    char testChar = str2[pair.Value[0]];

                    foreach (var index in pair.Value)
                    {
                        //check the char for each index is same or not
                        if (!str2[index].Equals(testChar))
                        {
                            return false;
                        }
                    }
                }

                //mapped every char in str2 with correspong char in str1 at the same index
                return true;
            }

        }

        #endregion

        #region  Excel columns

        public static int TitleToNumber(string input)
        {
            if (input == null || input.Length == 0)
            {
                throw new Exception("Input is not valid!");
            }

            int result = 0;
            int index = input.Length - 1;
            int power = 0;
            while (index >= 0)
            {
                result += ((int)Math.Pow(26, power) * (input[index] - 'A' + 1));
                power++;
                index--;
            }

            return result;
        }

        public static string NumberToTitle(int number)
        {
            //err check
            if (number < 0)
            {
                throw new Exception("invalid input");
            }

            StringBuilder output = new StringBuilder("");

            while (number > 0)
            {
                number--;
                char ch = (char)(number % 26 + 'A');
                number /= 26;

                output.Insert(0, ch);
            }

            return output.ToString();
        }

        #endregion

        #region Divide Unusual

        private static int UnusualDivide(int dividend, int divisor, out int remainder)
        {
            if (divisor == 0)
            {
                remainder = 0;
                return int.MaxValue;
            }
            else if (divisor == -1 && dividend == int.MinValue)
            {
                remainder = 0;
                return int.MaxValue;
            }
            else if (divisor == -1 && dividend == int.MaxValue)
            {
                remainder = 0;
                return int.MinValue;
            }
            else
            {
                bool ntive = false;

                if (divisor < 0)
                {
                    divisor = Math.Abs(divisor);
                    ntive = !ntive;
                }

                if (dividend < 0)
                {
                    dividend = Math.Abs(dividend);
                    ntive = !ntive;
                }

                int sum = 0, count = -1;

                while (sum <= dividend)
                {
                    sum += divisor;
                    count++;
                }

                remainder = dividend - (count * divisor);
                return ntive ? (count * (-1)) : count;
            }
        }

        #endregion

        #region Multiply Large

        public static string Multiply(string n1, string n2)
        {
            if (string.IsNullOrEmpty(n1.Trim()) || string.IsNullOrEmpty(n2.Trim()))
            {
                throw new Exception("Invalid input");
            }

            int len1 = n1.Length, len2 = n2.Length;
            int[] tempSum = new int[len1 + len2];

            //multiply each digit and sum at the corresponding positions
            for (int index1 = 0; index1 < len1; index1++)
            {
                for (int index2 = 0; index2 < len2; index2++)
                {
                    tempSum[index1 + index2] += (n1[len1 - index1 - 1] - '0') * (n2[len2 - index2 - 1] - '0');
                }
            }

            StringBuilder sb = new StringBuilder();

            //calculate each digit
            for (int index = 0; index < tempSum.Length; index++)
            {
                int mod = tempSum[index] % 10;
                int carry = tempSum[index] / 10;
                if (index + 1 < tempSum.Length)
                {
                    tempSum[index + 1] += carry;
                }
                sb.Insert(0, mod);
            }

            //remove front 0's
            while (sb[0] == '0' && sb.Length > 1)
            {
                sb.Remove(0, 1);
            }

            return sb.ToString();
        }

        #endregion

        #region KnuthShuffle

        private static int getRandom(int floor, int ceiling)
        {
            Random rand = new Random();
            return rand.Next((ceiling - floor) + 1) + floor;
        }

        private static void Swap(int a, int b)
        {
            var temp = a;
            a = b;
            b = temp;
        }

        private static void KnuthShuffle(int[] arr)
        {
            // if it's 1 or 0 items, just return
            if (null == arr || arr.Length <= 1) return;

            // walk through from beginning to end
            for (int chosenIndex = 0; chosenIndex < arr.Length; chosenIndex++)
            {

                // choose a random not-yet-placed item to place there
                // (could also be the item currently in that spot)
                // must be an item AFTER the current item, because the stuff
                // before has all already been placed
                int randomIndex = getRandom(chosenIndex, arr.Length - 1);

                // place our random choice in the spot by swapping
                int valueAtIndexWeChoseFor = arr[chosenIndex];
                arr[chosenIndex] = arr[randomIndex];
                arr[randomIndex] = valueAtIndexWeChoseFor;

            }
        }

        private static void MyShuffle(int[] arr)
        {
            // if it's 1 or 0 items, just return
            if (null == arr || arr.Length <= 1) return;

            //get half-length, and decide floor length of the array 
            //based on length % 2 to get random index
            int halfLength = arr.Length % 2 == 0 ? (arr.Length / 2) + 1 : arr.Length / 2;

            // walk through from beginning to end
            for (int chosenIndex = 0; chosenIndex <= halfLength; chosenIndex++)
            {

                // choose a random not-yet-placed item to place there
                // (could also be the item currently in that spot)
                // must be an item AFTER the current item, because the stuff
                // before has all already been placed
                int randomIndex = getRandom(chosenIndex, halfLength) + halfLength;

                // place our random choice in the spot by swapping
                int valueAtIndexWeChoseFor = arr[chosenIndex];
                arr[chosenIndex] = arr[randomIndex];
                arr[randomIndex] = valueAtIndexWeChoseFor;
            }
        }

        #endregion

        #region BuildWordCloud

        private static Dictionary<string, long> BuildStrCloud(string ip)
        {
            //err check
            if (string.IsNullOrEmpty(ip))
            {
                throw new Exception("invalid input");
            }
            else
            {
                Dictionary<string, long> wordsToCounts = new Dictionary<string, long>();

                //separator
                List<char> sep = new List<char>() { ' ', ',', '.', '!', '@', '#', '%', '$', '&', '(', ')',
                    '{', '}', '[', ']', '-', '_', '/', '\\', ';', ':', '"', '\'', '~', '`' };

                // iterates over each character in the input string, splitting
                // words and adding word to dictionary
                StringBuilder currentWord = new StringBuilder("");
                for (int index = 0; index < ip.Length; index++)
                {
                    // if we reached the end of the string we check if the last
                    // character is a letter and add the last word to our hash map
                    if (index == ip.Length - 1)
                    {
                        if (char.IsLetter(ip[index]))
                            currentWord.Append(ip[index]);

                        if (currentWord.Length != 0)
                            AddWordToHashMap(currentWord.ToString(), wordsToCounts);

                        continue;
                    }

                    // if the character is a hyphen, we want to check if it's surrounded by letters
                    // if it is, we add it to our current word
                    if (ip[index] == '-')
                    {
                        if (index > 0 && char.IsLetter(ip[index - 1])
                                && char.IsLetter(ip[index + 1]))
                        {
                            currentWord.Append(ip[index]);
                            continue;
                        }
                    }

                    // we want to make sure we split on ellipses so if we get two periods in
                    // a row we add the current word to our hash map and reset our current word
                    if (ip[index] == '.')
                    {
                        if (index < ip.Length - 1 && ip[index + 1] == '.')
                        {
                            if (currentWord.Length != 0)
                                AddWordToHashMap(currentWord.ToString(), wordsToCounts);
                            currentWord = new StringBuilder("");
                            continue;
                        }
                    }

                    // if we reach a space, or emdash we know we're at the end of a word
                    // so we add it to our hash map and reset our current word
                    if (sep.Contains(ip[index]))
                    {
                        if (currentWord.Length != 0)
                            AddWordToHashMap(currentWord.ToString(), wordsToCounts);
                        currentWord = new StringBuilder("");
                    }
                    //default case
                    else
                    {
                        currentWord.Append(ip[index]);
                    }
                }

                return wordsToCounts;
            }
        }


        private static void AddWordToHashMap(string word, Dictionary<string, long> wordsToCounts)
        {

            // if the word (lowercase) is already in the hash map we increment its count
            if (wordsToCounts.ContainsKey(word.ToLower()))
            {
                wordsToCounts[word.ToLower()]++;
            }
            //else add it with coumt as 1
            else
            {
                wordsToCounts.Add(word.ToLower(), 1);
            }
        }

        #endregion

        #region FindNumberAppearingTwice

        private static int FindNumberAppearingTwice(int[] arr)
        {
            //err check
            if (null == arr || arr.Length < 2)
            {
                throw new Exception("Invalifdinput");
            }
            else
            {
                int count = arr.Length - 1;
                long triSum = ((count * count) + count) / 2;

                //iterate and deduct each elemt from array
                foreach (int item in arr)
                {
                    triSum -= item;
                }

                return (int)((-1) * triSum);
            }

        }

        #endregion

        #region GetstringPermutations

        /// <summary>
        /// 
        /// </summary>
        /// <param name="inputstring"></param>
        /// <returns></returns>
        public static HashSet<string> GetstringPermutations(string inputstring)
        {

            // base case
            if (inputstring.Length <= 1)
            {
                return new HashSet<string>() { inputstring };
            }

            string allCharsExceptLast = inputstring.Substring(0, inputstring.Length - 1);
            char lastChar = inputstring[inputstring.Length - 1];

            // recursive call: get all possible permutations for all chars except last
            HashSet<string> permutationsOfAllCharsExceptLast = GetstringPermutations(allCharsExceptLast);

            // put the last char in all possible positions for each of the above permutations
            HashSet<string> permutations = new HashSet<string>();
            foreach (string permutationOfAllCharsExceptLast in permutationsOfAllCharsExceptLast)
            {
                for (int position = 0; position <= allCharsExceptLast.Length; position++)
                {
                    string permutation = permutationOfAllCharsExceptLast.Substring(0, position) + lastChar + permutationOfAllCharsExceptLast.Substring(position);
                    permutations.Add(permutation);  //this will fail if duplicate characters in inputstring, use List<T> for that instead of HasSet<T>
                }
            }

            return permutations;
        }

        #endregion

        #region Bracket Validator

        /// <summary>
        /// Method to validate a code section's brackets
        /// </summary>
        /// <param name="code">Code section</param>
        /// <param name="pairStr">bracket pairs separated by comma</param>
        /// <returns></returns>
        public static bool BracketValidator(string code, string pairStr = "(),{},[]")
        {
            //err check
            if (string.IsNullOrEmpty(code) || string.IsNullOrEmpty(pairStr))
            {
                Console.WriteLine("Nothing to validate");
                return false;
            }
            else
            {
                //create a dictionary out of pairs
                Dictionary<char, char> pairs = new Dictionary<char, char>();
                var allPairs = pairStr.Split(",".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                foreach (var item in allPairs)
                {
                    pairs.Add(item[0], item[1]);
                }

                //create stack to keep track of brackets
                Stack<char> openers = new Stack<char>();

                //scan the code and return false in case closer doesn't matches most recent opener
                for (int index = 0; index < code.Length; index++)
                {
                    Console.WriteLine(code[index]);
                    if (pairs.ContainsKey(code[index]))
                    {
                        openers.Push(code[index]);
                    }
                    else if (pairs.ContainsValue(code[index]))
                    {
                        if (openers.Count == 0)
                        {
                            Console.WriteLine("stack empty");
                            return false;
                        }
                        else
                        {
                            var temp = openers.Pop();

                            if (!pairs[temp].Equals(code[index]))
                            {
                                Console.WriteLine("Validation failed at {0}, char-count: {1}", code[index], index + 1);
                                return false;
                            }
                        }
                    }
                }

                return openers.Count == 0 ? true : false;
            }
        }

        #endregion

        #region Find Unique In Duplicates

        /// <summary>
        /// Find Unique In Duplicates
        /// </summary>
        /// <param name="idList"></param>
        /// <returns></returns>
        private static int FindUniqueInDuplicates(int[] idList)
        {
            //error check
            if (null == idList || idList.Length <= 0)
            {
                throw new Exception("Invalid input.");
            }
            else
            {
                int result = 0;

                //Bitwise XOR with all elements
                for (int index = 0; index < idList.Length; index++)
                {
                    result ^= idList[index];
                }

                return result;
            }
        }

        #endregion

        #region Inflight ENtertainment

        /// <summary>
        /// Find couples of distinct movies to watch during flight
        /// </summary>
        /// <param name="movieLengths">in minutes</param>
        /// <param name="flightLength">in minutes</param>
        /// <param name="indexes">list of movies fits perfectly with flight time</param>
        /// <returns>True if found any, else false</returns>
        public static bool GetTwoMoviesToFillFlight(int[] movieLengths, int flightLength, int range, out List<int[]> indexes)
        {
            //error check
            if (null == movieLengths || flightLength <= 0)
            {
                throw new Exception("invalid input");
            }

            indexes = new List<int[]>();

            // movie Lengths we've seen so far
            HashSet<int> movieLengthsSeen = new HashSet<int>();

            foreach (int movieLength in movieLengths)
            {
                for (int rangeTime = 0; rangeTime <= range; rangeTime++)
                {
                    int matchingSecondMovieLength = flightLength - movieLength - rangeTime;
                    if (movieLengthsSeen.Contains(matchingSecondMovieLength))
                    {
                        //add the movie indexes to the list which fits in time-frame
                        indexes.Add(new int[] { movieLength, matchingSecondMovieLength });
                    }
                }

                //add the current movie time to 
                movieLengthsSeen.Add(movieLength);
            }

            // if list is empty, return false, else true
            if (indexes.Count == 0)
            {
                return false;
            }
            else
                return true;
        }

        /*Bonus:
        * What if we wanted the movie Lengths to sum to something close to the flight Length(say, within 20 minutes)? What if we wanted to fill the flight Length as 
        * nicely as possible with any number of movies(not just 2) */
        /*
        /// <summary>
        /// Class for efficiently keeping records for each movie
        /// </summary>
        private class Movie
        {
            long mLength;           // The run time of each movie
            long mMovieCount;       // The number of movies that are this long
            long mMoviesWatched;    // The number of movies that are this long, and have been already allocated

            public Movie(long Length)
            {
                mLength = Length;
                mMovieCount = 1;
                mMoviesWatched = 0;
            }

            /// <summary>
            /// Check whether a movie is already watched or not
            /// </summary>
            /// <returns></returns>
            public bool WatchMovie()
            {
                if (mMoviesWatched >= mMovieCount) { return (false); };
                mMoviesWatched++;

                return (true);
            }

            public long MovieCount
            {
                get { return mMovieCount; }
                set { mMovieCount = value; }
            }

            public long MovieWatched
            {
                get { return mMoviesWatched; }
                set { mMoviesWatched = value; }
            }

            public long Length
            {
                get { return mLength; }
            }
        }

        private class MovieListWithinDuration
        {
            public static long TotalDuration { get; }

            public static List<long> movieIndexes = new List<long>();
        }
        
        public static bool GetMoviesToFillFlight(long flightLength, long[] movieLengths, int range, out List<long[]> indexes)
        {
            // This is inefficient compared to an approach that implements a sparse array which
            // uses the movie Length as the index.  We can use a dictionary 
            Dictionary<long, Movie> movies = new Dictionary<long, Movie>();

            foreach (var movieLength in movieLengths)
            {
                if (!movies.ContainsKey(movieLength))
                {
                    movies.Add(movieLength, new Movie(movieLength));
                    continue;
                }
                movies[movieLength].MovieCount++;
            }

            foreach (var movie in movies)
            {
                movie.Value.MovieWatched++;

                if (movies.ContainsKey(flightLength - movie.Value.Length))
                {
                    if (movies[flightLength - movie.Value.Length].WatchMovie())
                    {
                        //indexes.Add(new int[] { movieLength, matchingSecondMovieLength });
                        return (true);
                    }
                }

                aMovie.mMoviesWatched--;
            }
            return (false);
        }*/

        #endregion

        #region Test Method

        public static long binomial_coefficient(int n, int m)
        {
            long[,] bc = new long[30, 30];
            for (int i = 0; i <= n; i++) bc[i, 0] = 1;
            for (int j = 0; j <= n; j++) bc[j, j] = 1;
            for (int i = 1; i <= n; i++)
                for (int j = 1; j < i; j++)
                    bc[i, j] = bc[i - 1, j - 1] + bc[i - 1, j];
            return (bc[n, m]);
        }

        #endregion

        #region Find Rotaion of Sorted Array

        /// <summary>
        /// Find the index of first elementa nd it's index in sorted but rotated array
        /// </summary>
        /// <param name="input"></param>
        /// <param name="firstStr"></param>
        /// <returns>index</returns>
        public static int FindRotaionOfSortedArray(string[] input, out string firstStr)
        {
            //error check
            if (null == input || input.Length <= 0 || string.IsNullOrEmpty(input[0].Trim()))
            {
                throw new Exception("Invalid input");
            }
            else if (input.Length == 1)
            {
                //if only one element, then return it
                firstStr = input[0];
                return 0;
            }
            else
            {
                //get first item
                string first = input[0];

                //find floor and ceiling
                int floor = 0, ceiling = input.Length - 1;

                //iterate through till floor and ceiling converges or about to converge
                while (floor < ceiling)
                {
                    //guess an element in middle of floor and ceiling
                    int guess = (floor + (ceiling - floor)) / 2;

                    //check if element at guess if before or after first element
                    if (input[guess].CompareTo(first) > 0)
                    {
                        //go to right
                        floor = guess;
                    }
                    else
                    {
                        //go to left
                        ceiling = guess;
                    }

                    //check if floor and ceiling converge
                    //if yes, then ceiling is where we flip
                    if (floor + 1 == ceiling)
                    {
                        break;
                    }
                    //if floor and ceiling about to converge
                    //then we flip in middle of floor & ceiling
                    else if (floor + 2 == ceiling)
                    {
                        ceiling--;
                        break;
                    }
                }

                firstStr = input[ceiling];
                return ceiling;
            }

        }

        #endregion

        #region Balanced BinaryTree

        public class NodeDepthPair
        {

            public TreeNode node; //TreeNode class
            public int depth;

            public NodeDepthPair(TreeNode node, int depth)
            {
                this.node = node;
                this.depth = depth;
            }
        }

        /// <summary>
        /// Method to find a tree is 'super-balanced' or not
        /// </summary>
        /// <param name="treeRoot"></param>
        /// <returns></returns>
        public static bool IsTreeSuperBalanced(TreeNode treeRoot)
        {
            List<int> depths = new List<int>(3); // we short-circuit as soon as we find more than 2

            // nodes will store pairs of a node and the node's depth
            Stack<NodeDepthPair> nodes = new Stack<NodeDepthPair>();
            nodes.Push(new NodeDepthPair(treeRoot, 0));

            while (nodes.Count != 0)
            {

                // pop a node and its depth from the top of our stack
                NodeDepthPair nodeDepthPair = nodes.Pop();
                TreeNode node = nodeDepthPair.node;
                int depth = nodeDepthPair.depth;

                // case: we found a leaf
                if (node.Left == null && node.Right == null)
                {

                    // we only care if it's a new depth
                    if (!depths.Contains(depth))
                    {
                        depths.Add(depth);

                        // two ways we might now have an unbalanced tree:
                        //   1) more than 2 different leaf depths
                        //   2) 2 leaf depths that are more than 1 apart
                        if ((depths.Count > 2) ||
                                (depths.Count == 2 && Math.Abs(depths[0] - depths[1]) > 1))
                        {
                            return false;
                        }
                    }

                    // case: this isn't a leaf - keep stepping down
                }
                else {
                    if (node.Left != null)
                    {
                        nodes.Push(new NodeDepthPair(node.Left, depth + 1));
                    }
                    if (node.Right != null)
                    {
                        nodes.Push(new NodeDepthPair(node.Right, depth + 1));
                    }
                }
            }

            return true;
        }

        #endregion

        #region 2nd Largets in BST

        /// <summary>
        /// Find the largest
        /// </summary>
        /// <param name="rootNode"></param>
        /// <returns></returns>
        public static int FindLargest(TreeNode rootNode)
        {
            if (null == rootNode)
            {
                return int.MinValue;
            }

            TreeNode current = rootNode;
            while (current.Right != null)
            {
                current = current.Right;
            }

            return current.Data;
        }

        /// <summary>
        /// Find 2nd largest
        /// </summary>
        /// <param name="rootNode"></param>
        /// <returns></returns>
        public static int FindSecondLargest(TreeNode rootNode)
        {
            if (null == rootNode)
            {
                return int.MinValue;
            }
            else if (rootNode.Left == null && rootNode.Right == null)
            {
                throw new Exception("Tree must have at least 2 nodes");
            }

            TreeNode current = rootNode;

            while (true)
            {
                // case-1: current is largest and has a left subtree
                // 2nd largest is the largest in that subtree
                if (current.Left != null && current.Right == null)
                {
                    return FindLargest(current.Left);
                }

                // case-2: current is parent of largest, and
                // largest has no children, so
                // current is 2nd largest
                if (current.Right != null &&
                        current.Right.Left == null &&
                        current.Right.Right == null)
                {
                    return current.Data;
                }

                current = current.Right;
            }
        }

        #endregion

        #region BSTChecker

        /// <summary>
        /// Determine whether a binary tree is BST or not
        /// </summary>
        /// <param name="root"></param>
        /// <returns></returns>
        public static bool BSTChecker(TreeNode root)
        {
            return BSTCheckerRecursive(root, int.MinValue, int.MaxValue);
        }

        private static bool BSTCheckerRecursive(TreeNode root, int lowerBound, int upperBound)
        {
            if (root == null)
            {
                return true;
            }

            if (root.Data > upperBound || root.Data < lowerBound)
            {
                return false;
            }

            return BSTCheckerRecursive(root.Left, lowerBound, root.Data)
                && BSTCheckerRecursive(root.Right, root.Data, upperBound);
        }

        #endregion

        #region Rectangular overlap

        /// <summary>
        /// Find overlap
        /// </summary>
        /// <param name="r1"></param>
        /// <param name="r2"></param>
        /// <returns></returns>
        public static RangeOverlap FindOverlap(int point1, int Length1, int point2, int Length2)
        {
            // find the highest start point and lowest end point.
            // the highest ("rightmost" or "upmost") start point is
            // the start point of the overlap.
            // the lowest end point is the end point of the overlap.
            int highestStartPoint = Math.Max(point1, point2);
            int lowestEndPoint = Math.Min(point1 + Length1, point2 + Length2);

            // return null overlap if there is no overlap
            if (highestStartPoint >= lowestEndPoint)
            {
                return null;
            }

            // compute the overlap Length
            int overlapLength = lowestEndPoint - highestStartPoint;

            return new RangeOverlap(highestStartPoint, overlapLength);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="rect1"></param>
        /// <param name="rect2"></param>
        /// <returns></returns>
        public static Rectangle FindRectangularOverlap(Rectangle rect1, Rectangle rect2)
        {

            // get the x and y overlap points and Lengths
            RangeOverlap xOverlap = FindOverlap(rect1.LeftX, rect1.Width, rect2.LeftX, rect2.Width);
            RangeOverlap yOverlap = FindOverlap(rect1.BottomY, rect1.Height, rect2.BottomY, rect2.Height);

            // return null rectangle if there is no overlap
            if (xOverlap == null || yOverlap == null)
            {
                return null;
            }

            return new Rectangle(
                xOverlap.startPoint,
                yOverlap.startPoint,
                xOverlap.Length,
                yOverlap.Length
            );
        }

        /// <summary>
        /// Rectangle
        /// </summary>
        public class Rectangle
        {
            public int LeftX, BottomY, Width, Height;

            public Rectangle(int x, int y, int w, int h)
            {
                LeftX = x; BottomY = y; Width = w; Height = h;
            }

            public string ToString()
            {
                return string.Format("Rectangle: Left-X: {0}; Bottom-Y: {1}; Width: {2}; Height: {3}...", LeftX, BottomY, Width, Height);
            }

        }

        public class RangeOverlap
        {
            public int startPoint, Length;

            public RangeOverlap(int startPoint, int Length)
            {
                this.startPoint = startPoint;
                this.Length = Length;
            }
        }

        #endregion

        #region Tracker

        /// <summary>
        /// 
        /// </summary>
        public class TempTracker
        {
            #region Members

            ulong[] tempFreq;
            ulong modeFreq;
            int maxTemp, minTemp, mode, totalNumbers;
            double totalSum, mean;

            #endregion

            #region Constructors

            public TempTracker(int range)
            {
                range++;

                tempFreq = new ulong[range];
                for (int index = 0; index < range; index++)
                {
                    tempFreq[index] = 0;
                }

                totalSum = 0.0;
                modeFreq = 0;
                maxTemp = -1;
                minTemp = -1;
                mode = -1;
                totalNumbers = 0;
            }

            #endregion

            #region Methods

            /// <summary>
            /// Insert a temperature in the series
            /// </summary>
            /// <param name="temp"></param>
            /// <returns>True if success, else false</returns>
            public bool Insert(int temp)
            {
                //error check
                if (temp < 0 || temp >= tempFreq.Length)
                {
                    Console.WriteLine("Invalid tempurature. Allowed ranges is 0 to {0}", tempFreq.Length - 1);
                    return false;
                }

                //basic operations
                tempFreq[temp]++;
                totalNumbers++;
                totalSum += (double)temp;

                //Mode
                if (mode == -1 || tempFreq[temp] > modeFreq)
                {
                    mode = temp;
                    modeFreq = tempFreq[temp];
                }

                //Mean
                mean = totalSum / totalNumbers;

                //Min & Max
                if (maxTemp == -1 || temp > maxTemp)
                {
                    maxTemp = temp;
                }
                if (minTemp == -1 || temp < minTemp)
                {
                    minTemp = temp;
                }

                return true;
            }

            /// <summary>
            /// Get Max temperature
            /// </summary>
            /// <returns></returns>
            public int GetMax()
            {
                if (totalSum != 0.0)
                {
                    return maxTemp;
                }
                else
                    throw new Exception("Please insert at least one temperature, before getting max temperature.");
            }

            /// <summary>
            /// Get Min temp
            /// </summary>
            /// <returns></returns>
            public int GetMin()
            {
                if (totalSum != 0.0)
                {
                    return minTemp;
                }
                else
                    throw new Exception("Please insert at least one temperature, before getting min temperature.");
            }

            /// <summary>
            /// Get Mean
            /// </summary>
            /// <returns></returns>
            public double GetMean()
            {
                if (totalSum != 0.0)
                {
                    return mean;
                }
                else
                    throw new Exception("Please insert at least one temperature, before getting mean temperature.");
            }

            /// <summary>
            /// Get Mode
            /// </summary>
            /// <returns></returns>
            public int GetMode()
            {
                if (totalSum != 0.0)
                {
                    return mode;
                }
                else
                    throw new Exception("Please insert at least few temperature, before getting mode of the temperatures.");
            }

            #endregion
        }

        #endregion

        #region MergeMeetings
        /// <summary>
        /// Method to merge overlapping meeting times
        /// </summary>
        /// <param name="times"></param>
        /// <returns></returns>
        internal static Meeting[] MergeMeetings(Meeting[] times)
        {
            //error check
            if (null == times || times.Length < 2)
            {
                Console.WriteLine("Nothing to merge here.");
                return times;
            }
            else
            {
                Array.Sort(times, Compare);

                // meetings only go in mergedMeetings when we're sure they can't be merged further
                List<Meeting> mergedMeetings = new List<Meeting>();

                Meeting previousMeeting = times[0];

                foreach (var meeting in times)
                {
                    // if the previous meeting can be merged with the current one
                    // that is, if current meeting starts before previous meeting ends:
                    if (meeting.Start <= previousMeeting.End)
                    {

                        // merge the currentMeeting back into the previousMeeting
                        // and keep the resulting meeting as the previousMeeting
                        // because this newly-merged meeting might still
                        // need to be merged with the next meeting
                        previousMeeting.End = Math.Max(meeting.End, previousMeeting.End);

                    }
                    // else the previous meeting can't be merged with anything else
                    else
                    {

                        // put it in mergedMeetings
                        // and move on to trying to merge the current meeting into subsequent meetings
                        mergedMeetings.Add(new Meeting(previousMeeting.Start, previousMeeting.End));

                        previousMeeting = meeting;
                    }
                }

                // put last meeting we were trying to merge in our final set
                mergedMeetings.Add(new Meeting(previousMeeting.Start, previousMeeting.End));

                return mergedMeetings.ToArray();
            }
        }

        /// <summary>
        /// Comparion method for two meetings
        /// </summary>
        /// <param name="m1"></param>
        /// <param name="m2"></param>
        /// <returns></returns>
        private static int Compare(Meeting m1, Meeting m2)
        {
            return m1.Start - m2.Start;
        }

        #endregion

        #region ProductsOfAllIntsExceptAtIndex
        /// <summary>
        /// 
        /// </summary>
        /// <param name="inputArr"></param>
        /// <returns></returns>
        public static long[] ProductsOfAllIntsExceptAtIndex(int[] inputArr)
        {
            //errorcheck
            if (null == inputArr || inputArr.Length <= 1)
            {
                throw new Exception("invalid inpu provided.");
            }
            else
            {
                long[] outputArr = new long[inputArr.Length];
                long productSoFar = 1;

                //1st run: find product of all values upto index - 1 position
                for (int index = 0; index < inputArr.Length; index++)
                {
                    outputArr[index] = productSoFar;
                    productSoFar *= inputArr[index];
                }

                //reset product so far to start multiplying from end
                productSoFar = 1;

                //2nd run: find product of all values starting from index + 1 position
                for (int index = inputArr.Length - 1; index >= 0; index--)
                {
                    outputArr[index] *= productSoFar;
                    productSoFar *= inputArr[index];
                }

                return outputArr;
            }
        }

        #endregion

        #region FindMaxShareProfit

        /// <summary>
        /// Method to find max share profit from yesterday's share prices
        /// </summary>
        /// <param name="yesterdaysShareList"></param>
        /// <returns>Max profit amount</returns>
        public static int FindMaxShareProfit(int[] yesterdaysShareList)
        {
            //error check
            if (null == yesterdaysShareList || yesterdaysShareList.Length < 2)
            {
                throw new Exception("Need a proper share-list from yesterday's stock prices.");
            }
            else
            {
                //using greedy approach and starting with lowest share value as 1st element 
                //and max profit as if we sell in very next hour(index = 1)
                int minPrice = yesterdaysShareList[0];
                int maxProfit = yesterdaysShareList[1] - yesterdaysShareList[0];

                //iterate through all share values once and update minPrice and maxProfit accordingly
                //but start from 2nd element as finding profit required 2 values
                for (int index = 1; index < yesterdaysShareList.Length; index++)
                {
                    int potentialProfit = yesterdaysShareList[index] - minPrice;

                    //find max profit
                    maxProfit = Math.Max(potentialProfit, maxProfit);

                    //find min price
                    minPrice = Math.Min(minPrice, yesterdaysShareList[index]);
                }

                return maxProfit;
            }
        }

        #endregion

        #region FindLowestNumberPostRemoval
        /// <summary>
        /// 
        /// </summary>
        /// <param name="input"></param>
        /// <param name="numberToDelete"></param>
        /// <returns></returns>
        public static string FindLowestNumberPostRemoval(string input, int numberToDelete)
        {
            //error checks
            if (string.IsNullOrEmpty(input.Trim()) || numberToDelete < 1 || numberToDelete > input.Length)
            {
                throw new Exception("Invalid Input.");
            }
            else
            {
                StringBuilder sbTemp = new StringBuilder(input);

                //iterate only upto number of digits to delete 
                for (int index1 = 0; index1 < numberToDelete; index1++)
                {
                    int max = int.MinValue;
                    int maxIndex = 0;
                    int Length = sbTemp.Length;

                    //Find the max number and it's index
                    for (int index2 = 0; index2 < Length; index2++)
                    {
                        var temp = int.MinValue;
                        if (!int.TryParse(sbTemp[index2].ToString(), out temp))
                        {
                            throw new Exception("Invalid character in input number.");
                        }
                        else if (max < temp)
                        {
                            max = temp;
                            maxIndex = index2;
                        }
                    }

                    //remove the largest number
                    sbTemp.Remove(maxIndex, 1);
                }

                return sbTemp.ToString();
            }
        }
        #endregion

        #region Best Fibbo Ever

        /// <summary>
        /// Best fibbo solution ever, cam calculate upto 91st number
        /// Series: 0, 1, 1, 2, 3, 5, 8, 13 ...
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        private static long Fibbonachi(string value, out long sum)
        {
            int input = 0;

            if (string.IsNullOrEmpty(value) || !int.TryParse(value, out input))
            {
                throw new Exception("Inavlid value passed.");
            }
            else if (input <= 0)
            {
                throw new Exception("Term number should be greater than 0.");
            }
            else if (input == 1)
            {
                sum = 0;
                return 0;
            }
            else if (input == 2)
            {
                sum = 1;
                return 1;
            }
            else if (input == 3)
            {
                sum = 2;
                return 1;
            }
            else
            {
                long firstPrev = 1, secondPrev = 1;
                sum = 2;

                for (int index = 3; index < input; index++)
                {
                    firstPrev = firstPrev + secondPrev;
                    secondPrev = firstPrev - secondPrev;

                    sum += (firstPrev);
                }

                return (firstPrev);
            }
        }

        /// <summary>
        /// Fibbo calculation using matric multiplication
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        private static int FibboByMatricMultiply(int input)
        {
            if (input < 0)
            {
                throw new Exception("Term number should be greater than 0.");
            }
            else
            {
                int[,] f1 = { { 1, 1 }, { 1, 0 } };

                if (input == 0)
                    return 0;

                Power(f1, input - 1);

                return f1[0, 0];
            }
        }

        //Helper function that multiplies 2 matricies f1 and f1 of size 2*2, and puts the multiplication result back to f1[][] 
        private static void Multiply(int[,] f1, int[,] f2)
        {
            int x = f1[0, 0] * f2[0, 0] + f1[0, 1] * f2[1, 0];
            int y = f1[0, 0] * f2[0, 1] + f1[0, 1] * f2[1, 1];
            int z = f1[1, 0] * f2[0, 0] + f1[1, 1] * f2[1, 0];
            int w = f1[1, 0] * f2[0, 1] + f1[1, 1] * f2[1, 1];

            f1[0, 0] = x;
            f1[0, 1] = y;
            f1[1, 0] = z;
            f1[1, 1] = w;
        }

        //Helper function that calculates f1[][] raise to the power n and puts the result in f1[][]. Note that this function is desinged only for fib() and won't work as general power function
        private static void Power(int[,] f1, int power)
        {
            int[,] f2 = new int[,] { { 1, 1 }, { 1, 0 } };

            // n - 1 times multiply the matrix to {{1,0},{0,1}}
            for (int index = 2; index < power; index++)
            {
                Multiply(f1, f2);
            }
        }

        #endregion

        #region PowerSet
        public static List<string> GetAllUniqueSubset(char[] input)
        {
            List<string> lists = new List<string>();

            for (int index1 = 0; index1 < input.Length; index1++)
            {
                //traverse through all characters
                lists.AddRange(Substring(input, "", index1));
            }

            return lists;
        }

        private static List<string> Substring(char[] input, string substr, int index)
        {
            List<string> list = new List<string>();

            string str1 = substr + input[index]; //append the subset so far
            list.Add(str1); //print

            for (int index2 = index + 1; index2 < input.Length; index2++)
                list.AddRange(Substring(input, str1, index2)); //call recursively

            return list;
        }
        #endregion

        #region N-Queens

        /// <summary>
        /// Solution for NQueens
        /// </summary>
        /// <param name="order"></param>
        /// <returns></returns>
        public static List<bool[,]> FindNQueens(int order)
        {
            List<bool[,]> result = new List<bool[,]>();

            //error check
            if (order <= 0)
                throw new Exception("invalid board size");

            //Just for one cell
            if (order == 1)
            {
                var temp = new bool[1, 1];
                temp[0, 0] = true;
                result.Add(temp);
            }
            else
            {
                bool[,] board = new bool[order, order];

                //ACtuall solving
                if (SolveNQueen(board, order, 0))
                {
                    result.Add(board);
                    PrintBoards(board, order);
                }
                else
                {
                    Console.WriteLine("Not Solvable.");
                    return null;
                }
            }

            return result;
        }

        /// <summary>
        /// Print NQueens solution
        /// </summary>
        /// <param name="board"></param>
        private static void PrintBoards(bool[,] board, int order)
        {
            for (int index1 = 0; index1 < order; index1++)
            {
                Console.WriteLine();
                Console.WriteLine(new StringBuilder().Append('-', order * 3));

                for (int index2 = 0; index2 < order; index2++)
                {
                    Console.Write("|{0}|", board[index1, index2] ? "Q" : "-");
                }
            }

            Console.WriteLine();
            Console.WriteLine(new StringBuilder().Append('-', order * 3));
        }

        /// <summary>
        /// Determine locations for Queen in a column
        /// </summary>
        /// <param name="board"></param>
        /// <param name="order"></param>
        /// <param name="col"></param>
        /// <returns></returns>
        private static bool SolveNQueen(bool[,] board, int order, int col)
        {
            //base case: If all queens are placed then return true
            if (col >= order)
                return true;

            //Consider this column and try placing this queen in all rows one by one
            for (int index = 0; index < order; index++)
            {
                //Check if queen can be placed on board[i][col]
                if (IsSafe(board, order, index, col))
                {
                    //Place this queen in board[i][col]
                    board[index, col] = true;

                    //recur to place rest of the queens
                    if (SolveNQueen(board, order, col + 1))
                        return true;

                    //If placing queen in board[i][col] doesn't lead to a solution then remove queen from board[i][col]
                    board[index, col] = false; // BACKTRACK
                }
            }

            //If queen can not be place in any row in this colum col, then return false
            return false;
        }

        /// <summary>
        /// Validate whether Queen can be planed in Board cell of [row][col]
        /// </summary>
        /// <param name="board"></param>
        /// <param name="row">0 based</param>
        /// <param name="col">0 based</param>
        /// <returns>True if safe</returns>
        private static bool IsSafe(bool[,] board, int order, int row, int col)
        {
            /* Check this row on left side */
            for (int index1 = 0; index1 < col; index1++)
                if (board[row, index1])
                    return false;

            /* Check upper diagonal on left side */
            for (int index1 = row, index2 = col; index1 >= 0 && index2 >= 0; index1--, index2--)
                if (board[index1, index2])
                    return false;

            /* Check lower diagonal on left side */
            for (int index1 = row, index2 = col; index2 >= 0 && index1 < order; index1++, index2--)
                if (board[index1, index2])
                    return false;

            return true;
        }

        #endregion

        #region string Related

        /// <summary>
        /// Method to check a pattern in a string
        /// </summary>
        /// <param name="source"></param>
        /// <param name="pattern"></param>
        /// <returns>True if pattern is found</returns>
        public static bool Mystring_Contains(char[] source, char[] pattern)
        {
            //error and null check
            if (null == source || source.Length == 0 || null == pattern || pattern.Length == 0)
            {
                return false;
            }
            else
            {
                bool result = false;        //could have avoided this, but then we would have to return from inside the loop

                //iterate through the source, so time should be O(n), n being Length of source; space is in O(1)
                //if we had fixed source, we could have pre-processed and generated a trie and then pattern finding would have been in O(lgn) but space will take upto O(n)
                for (int index1 = 0, index2 = 0; index1 < source.Length && index2 < pattern.Length; index1++)
                {
                    //if match
                    if (source[index1].Equals(pattern[index2]))
                    {
                        //check if last character in pattern 
                        if (index2 == pattern.Length - 1)
                        {
                            result = true;
                            break;
                        }
                        //if pattern is not exhausted, then move to next char in pattern
                        else
                        {
                            index2++;
                        }
                    }
                    //if not a match, reset pattern index
                    else
                    {
                        index2 = 0;
                    }
                }

                return result;
            }

        }

        /// <summary>
        /// Method to check whether current string is duplicate of an older string
        /// </summary>
        /// <param name="current"></param>
        /// <param name="old"></param>
        /// <returns>true if duplicate</returns>
        public static bool Mystring_Duplicate(char[] current, char[] old)
        {
            //error and null check
            if (null == current || current.Length == 0 || null == old || old.Length == 0)
            {
                return false;
            }
            else
            {
                return AreEqualstringDictionary(GetstringDictionary(current), GetstringDictionary(old));
            }
        }

        /// <summary>
        /// Method to compare string dictionaries
        /// </summary>
        /// <param name="obj1"></param>
        /// <param name="obj2"></param>
        /// <returns>true if equal</returns>
        private static bool AreEqualstringDictionary(Dictionary<char, FrequencyAndIndexes> obj1, Dictionary<char, FrequencyAndIndexes> obj2)
        {
            //error check
            if (null == obj2 || null == obj1)
            {
                return false;
            }
            else if (obj1.Count != obj2.Count)
            {
                return false;
            }
            else
            {
                foreach (var keyItem in obj1.Keys)
                {
                    if (!obj2.ContainsKey(keyItem))
                    {
                        return false;
                    }
                    else if (obj2[keyItem].Frequency != obj1[keyItem].Frequency || obj2[keyItem].Indexes.Count != obj1[keyItem].Indexes.Count)
                    {
                        return false;
                    }
                    else
                    {
                        foreach (var index in obj1[keyItem].Indexes)
                        {
                            if (!obj2[keyItem].Indexes.Contains(index))
                            {
                                return false;
                            }
                        }
                    }
                }

                return true;
            }
        }

        /// <summary>
        /// Method to get a string dictionary from  character array (string)
        /// </summary>
        /// <param name="array"></param>
        /// <returns></returns>
        private static Dictionary<char, FrequencyAndIndexes> GetstringDictionary(char[] array)
        {
            //Error/null check
            if (null == array || array.Length == 0)
            {
                return new Dictionary<char, FrequencyAndIndexes>(0);
            }
            else
            {
                Dictionary<char, FrequencyAndIndexes> result = new Dictionary<char, FrequencyAndIndexes>();

                for (int index = 0; index < array.Length; index++)
                {
                    //if char is already known
                    if (result.ContainsKey(array[index]))
                    {
                        FrequencyAndIndexes temp = result[array[index]];
                        temp.Frequency += 1;
                        temp.Indexes.Add(index);

                        result[array[index]] = temp;
                    }
                    //for new chars
                    else
                    {
                        FrequencyAndIndexes temp = new FrequencyAndIndexes()
                        {
                            Frequency = 1,
                            Indexes = new List<int>() { index },
                        };

                        result.Add(array[index], temp);
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Structure to store the frequency and indexes
        /// </summary>
        struct FrequencyAndIndexes
        {
            public int Frequency;
            public List<int> Indexes;
        }

        #endregion

        #region Others.
        /// <summary>
        /// Find pattern
        /// </summary>
        /// <param name="patternstring"></param>
        /// <param name="sourcestring"></param>
        /// <returns></returns>
        private static unsafe int FindMatch(string patternstring, string sourcestring)
        {
            fixed (char* pattern = patternstring)
            {
                fixed (char* source = sourcestring)
                {
                    int patternLength = Strlen(pattern);
                    int sourceStrLength = Strlen(source);

                    for (int index1 = 0; index1 <= (sourceStrLength - patternLength); index1++)
                    {
                        int index2 = 0;
                        while (index2 < patternLength && source[index1 + index2] == pattern[index2])
                        {
                            Console.WriteLine(source[index1 + index2]);
                            Console.WriteLine(pattern[index2]);
                            index2++;
                        }

                        if (index2 == patternLength)
                            return (index1);
                    }
                }
            }

            return (-1);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="v1"></param>
        /// <returns></returns>
        private static unsafe int Strlen(char* v1)
        {
            if (v1 == null)
            {
                return 0;
            }
            else
            {
                var t1 = v1;
                return *(((int*)t1) - 1);
            }
        }

        #endregion

        #region Sorting

        /// <summary>
        /// Instertion Sort
        /// </summary>
        /// <param name="arr"></param>
        private static void InsertionSort(int[] arr)
        {
            var Length = arr.Length;

            for (int index1 = 0; index1 < Length; index1++)
            {
                for (int index2 = index1; index2 > 0; index2--)
                {
                    if (arr[index2] < arr[index2 - 1])
                    {
                        arr[index2] = arr[index2] + arr[index2 - 1];
                        arr[index2 - 1] = arr[index2] - arr[index2 - 1];
                        arr[index2] = arr[index2] - arr[index2 - 1];
                    }
                }
            }
        }

        /// <summary>
        /// ethod to swap two values
        /// </summary>
        /// <param name="v1"></param>
        /// <param name="v2"></param>
        private static void Swap(ref int v1, ref int v2)
        {
            v1 += v2;
            v2 = v1 - v2;
            v1 -= v2;
        }

        /// <summary>
        /// Actually sorting and merging
        /// </summary>
        /// <param name="arr"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <returns></returns>
        private static int[] MergeSort(int[] arr)
        {
            if (arr.Length <= 1)
            {
                return arr;
            }
            else
            {
                int mid = arr.Length / 2;
                int[] part1 = new int[mid], part2 = new int[arr.Length - mid];

                Array.Copy(arr, part1, mid);
                Array.Copy(arr, mid, part2, 0, part2.Length);

                part1 = MergeSort(part1);
                part2 = MergeSort(part2);
                return MergeDown(part1, part2);
            }
        }

        /// <summary>
        /// Merge the sorted parts
        /// </summary>
        /// <param name="part1"></param>
        /// <param name="part2"></param>
        /// <returns></returns>
        private static int[] MergeDown(int[] part1, int[] part2)
        {
            int[] retuningArr = new int[part2.Length + part2.Length];

            for (int index1 = 0, index2 = 0, index3 = 0; index1 < part1.Length || index2 < part2.Length;)
            {
                if (index1 < part1.Length && index2 < part2.Length)
                {
                    if (part1[index1] <= part2[index2])
                    {
                        retuningArr[index3++] = part1[index1++];
                    }
                    else
                    {
                        retuningArr[index3++] = part2[index2++];
                    }
                }
                else if (index1 < part1.Length)
                {
                    retuningArr[index3++] = part1[index1++];
                }
                else if (index2 < part2.Length)
                {
                    retuningArr[index3++] = part2[index2++];
                }
                else
                {
                    Console.WriteLine("Something is not right.");
                    break;
                }
            }

            return retuningArr;
        }

        /// <summary>
        /// Quick Sort
        /// </summary>
        /// <param name="arr"></param>
        private static void QuickSort(int[] arr)
        {
            tc = 0;
            QuickSort_Recursive(arr, 0, arr.Length - 1);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="arr"></param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        private static void QuickSort_Recursive(int[] arr, int left, int right)
        {
            // For Recusrion
            if (left < right)
            {
                int pivot = Partition(arr, left, right);

                if (pivot > 1)
                    QuickSort_Recursive(arr, left, pivot - 1);

                if (pivot + 1 < right)
                    QuickSort_Recursive(arr, pivot + 1, right);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="arr"></param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns></returns>
        private static int Partition(int[] arr, int left, int right)
        {
            int pivot = arr[left];
            while (true)
            {
                while (arr[left] < pivot)
                { left++; tc++; }

                while (arr[right] > pivot)
                { right--; tc++; }

                //Handle duplicate numbers
                if (arr[right] == pivot && arr[left] == pivot)
                {
                    left++;
                    tc++;
                }

                if (left < right)
                {
                    Swap(ref arr[right], ref arr[left]);
                }
                else
                {
                    return right;
                }
            }
        }

        /// <summary>
        /// Heap Sort
        /// </summary>
        /// <param name="arr"></param>
        private static void HeapSort(int[] arr)
        {
            tc = 0;

            //Build-Max-Heap
            int heapSize = arr.Length;
            for (int index = (heapSize - 1) / 2; index >= 0; index--)
                MaxHeapify(arr, heapSize, index);

            for (int index = arr.Length - 1; index > 0; index--)
            {
                tc++;

                //Swap
                Swap(ref arr[index], ref arr[0]);

                heapSize--;
                MaxHeapify(arr, heapSize, 0);
            }
        }

        /// <summary>
        /// Max Heapify
        /// </summary>
        /// <param name="arr"></param>
        /// <param name="heapSize"></param>
        /// <param name="index"></param>
        private static void MaxHeapify(int[] arr, int heapSize, int index)
        {
            tc++;

            int left = (index + 1) * 2 - 1;
            int right = (index + 1) * 2;
            int largest = 0;

            if (left < heapSize && arr[left] > arr[index])
                largest = left;
            else
                largest = index;

            if (right < heapSize && arr[right] > arr[largest])
                largest = right;

            if (largest != index)
            {
                //Swap
                Swap(ref arr[index], ref arr[largest]);

                //Heapify
                MaxHeapify(arr, heapSize, largest);
            }
        }

        private static List<int[]> GetRandomArray1()
        {
            Random rand = new Random();
            int[] input = new int[1000];
            int[] input1 = new int[1000];
            for (int index = 0; index < 1000; index++)
            {
                var temp = rand.Next(1000, 9999);
                input[index] = temp;
                input1[index] = temp;

                if (index > 750)
                {
                    input1[index] = input1[index - 500];
                }
            }

            return new List<int[]>() { input, input1 };
        }

        private static int[] CopyArray1(int[] arr)
        {
            int[] arr1 = new int[arr.Length];

            for (int index = 0; index < arr.Length; index++)
            {
                arr1[index] = arr[index];
            }

            return arr;
        }

        #region Counting Sort

        /// <summary>
        /// Countint sort: O(n+k) space and time
        /// uses sorted-dictionary to count and sorts in-place
        /// n being number of elements 
        /// k being delta of highest and smallest value in the array
        /// </summary>
        /// <param name="array">unsorted array</param>
        /// <returns></returns>
        private static int[] CountingSort(int[] array)
        {
            //err check
            if (null == array || array.Length < 2)
            {
                return array;
            }
            else
            {
                int[] sortedArray = new int[array.Length];

                // find smallest and largest value
                int minVal = array[0];
                int maxVal = array[0];
                for (int i = 1; i < array.Length; i++)
                {
                    if (array[i] < minVal) minVal = array[i];
                    else if (array[i] > maxVal) maxVal = array[i];
                }

                // init array of frequencies
                int[] counts = new int[maxVal - minVal + 1];

                // init the frequencies
                for (int i = 0; i < array.Length; i++)
                {
                    counts[array[i] - minVal]++;
                }

                // recalculate
                counts[0]--;
                for (int i = 1; i < counts.Length; i++)
                {
                    counts[i] = counts[i] + counts[i - 1];
                }

                // Sort the array
                for (int i = array.Length - 1; i >= 0; i--)
                {
                    sortedArray[counts[array[i] - minVal]--] = array[i];
                }

                return sortedArray;
            }
        }

        #endregion

        #endregion

        #region Soln. 4-8:

        public static bool ContainsTree(TreeNode t1, TreeNode t2)
        {
            if (t2 == null)
            {
                return true; // The empty tree is a subtree of every tree.
            }

            return SubTree(t1, t2);
        }

        /* Checks if the binary tree rooted at node1 contains the binary tree 
         * rooted at node2 as a subtree somewhere within it.
         */
        public static bool SubTree(TreeNode node1, TreeNode node2)
        {
            if (node1 == null)
            {
                // big tree empty & subtree still not found.
                return false;
            }

            if (node1.Data == node2.Data)
            {
                if (MatchTree(node1, node2))
                {
                    return true;
                }
            }

            return (SubTree(node1.Left, node2) || SubTree(node1.Right, node2));
        }

        /* Checks if the binary tree rooted at node1 contains the 
         * binary tree rooted at node2 as a subtree starting at node1.
         */
        public static bool MatchTree(TreeNode node1, TreeNode node2)
        {
            if (node2 == null && node1 == null)
            {
                // nothing left in the subtree
                return true;
            }

            if (node1 == null || node2 == null)
            {
                //  big tree empty & subtree still not found
                return false;
            }

            if (node1.Data != node2.Data)
            {
                // data doesn’t match
                return false;
            }

            return (MatchTree(node1.Left, node2.Left) && MatchTree(node1.Right, node2.Right));
        }

        #endregion

        #region Soln. 4-7:

        /// <summary>
        /// Result class
        /// </summary>
        public class AncesstorHelperResult
        {
            public bool IsAncesstor;
            public TreeNode root;

            public AncesstorHelperResult(TreeNode node, bool isAncstr)
            {
                IsAncesstor = isAncstr;
                root = node;
            }
        }

        /// <summary>
        /// Method t0 find the first common ancesstor of two nodes in tree
        /// </summary>
        /// <param name="root"></param>
        /// <param name="node1"></param>
        /// <param name="node2"></param>
        /// <returns></returns>
        public static TreeNode FindCommonAncesstor(TreeNode root, TreeNode node1, TreeNode node2)
        {
            if (root == null || node1 == null || node2 == null)
            {
                return null;
            }
            else
            {
                AncesstorHelperResult result = FindCmnAncHelper(root, node1, node2);
                if (result.IsAncesstor)
                {
                    return result.root;
                }
                else
                {
                    return null;
                }
            }
        }

        private static AncesstorHelperResult FindCmnAncHelper(TreeNode root, TreeNode node1, TreeNode node2)
        {
            if (root == null)
            {
                //check for null or leaf elements
                return new AncesstorHelperResult(null, false);
            }

            if (root == node1 && root == node2)
            {
                //check for tree root
                return new AncesstorHelperResult(root, true);
            }


            //check left subtree
            var leftResult = FindCmnAncHelper(root.Left, node1, node2);
            if (leftResult.IsAncesstor)
            {
                return leftResult;
            }

            //check right subtree
            var rightResult = FindCmnAncHelper(root.Right, node1, node2);
            if (rightResult.IsAncesstor)
            {
                return rightResult;
            }

            if (leftResult.root != null && rightResult.root != null)
            {
                //if both left and right subtree doesn't have commn. ancsstr then root is the result
                return new AncesstorHelperResult(root, true);
            }
            else if (root == node1 || root == node2)
            {
                //if we at node1 or node2 and we already have those nodes, then this is commn. ancsstr
                return new AncesstorHelperResult(root, ((leftResult.root != null || rightResult.root != null) ? true : false));
            }
            else
            {
                //common ancesstor not found
                return new AncesstorHelperResult(leftResult.root != null ? leftResult.root : rightResult.root, false);
            }
        }

        #endregion

        #region Soln. 4-6:

        /// <summary>
        /// Fidn the left mode node
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        private static TreeNode LeftMOstChild(TreeNode node)
        {
            if (node == null)
            {
                return null;
            }
            else
            {
                while (node.Left != null)
                {
                    node = node.Left;
                }

                return node;
            }
        }

        /// <summary>
        /// Find in-order successor
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        private static TreeNode InorderSucc(TreeNode node)
        {
            if (node == null)
            {
                return null;
            }
            //if root element
            else if (node.Parent == null || node.Right != null)
            {
                return LeftMOstChild(node.Right);
            }
            else
            {
                var current = node;
                var parent = current.Parent;

                while (parent != null && parent.Left != current)
                {
                    current = parent;
                    parent = parent.Parent;
                }

                return parent;
            }
        }

        #endregion

        #region Soln. 4-5:

        /// <summary>
        /// Method to check BST
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        public static bool IsBst(TreeNode node)
        {
            return IsBst(node, int.MaxValue, int.MinValue);
        }

        /// <summary>
        /// Validate with max min range
        /// </summary>
        /// <param name="node"></param>
        /// <param name="max"></param>
        /// <param name="min"></param>
        /// <returns></returns>
        private static bool IsBst(TreeNode node, int max, int min)
        {
            if (node == null)
            {
                return true;
            }

            if (min <= node.Data && node.Data < max)
            {
                if (IsBst(node.Left, node.Data, min) && IsBst(node.Right, max, node.Data))
                {
                    return true;
                }
                else
                    return false;
            }
            else
                return false;
        }

        #endregion

        #region Soln. 4-4:

        /// <summary>
        /// Method to create a linked list based on per level of a tree.
        /// </summary>
        /// <param name="root"></param>
        /// <returns></returns>
        public static List<LinkedList<TreeNode>> CreateLevelLinkedList(TreeNode root)
        {
            if (root == null)
            {
                return new List<LinkedList<TreeNode>>();
            }
            else
            {
                var result = new List<LinkedList<TreeNode>>();

                /* "Visit" the root */
                var current = new LinkedList<TreeNode>();
                current.AddFirst(root);

                while (current.Count > 0)
                {
                    // Add previous level
                    result.Add(current);

                    // Go to next level
                    var parents = current;
                    current = new LinkedList<TreeNode>();

                    foreach (var parent in parents)
                    {
                        /* Visit the children */
                        if (parent.Left != null)
                        {
                            current.AddLast(parent.Left);
                        }

                        if (parent.Right != null)
                        {
                            current.AddLast(parent.Right);
                        }
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Method to create linked list for each level in a tree
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        public static List<LinkedList<TreeNode>> CreateLevelListRecursively(TreeNode node)
        {
            List<LinkedList<TreeNode>> result = new List<LinkedList<TreeNode>>();
            CreateLevelLinkedList(node, result, 0);

            return result;
        }

        /// <summary>
        /// Method to create the list recursively from a tree
        /// </summary>
        /// <param name="node"></param>
        /// <param name="result"></param>
        /// <param name="level"></param>
        private static void CreateLevelLinkedList(TreeNode node, List<LinkedList<TreeNode>> result, int level)
        {
            //if node is empty return
            if (node == null)
            {
                return;
            }
            else
            {
                LinkedList<TreeNode> current = null;

                //check if this the first time in this level
                if (result.Count == level)
                {
                    current = new LinkedList<TreeNode>();
                    //if yes, add new data
                    result.Add(current);
                }
                else
                {
                    //if not, fetch old data
                    current = result[level];
                }

                //traverse in order
                current.AddLast(node);
                CreateLevelLinkedList(node.Left, result, level + 1);
                CreateLevelLinkedList(node.Right, result, level + 1);
            }
        }

        /// <summary>
        /// Print the leveled linkded lists
        /// </summary>
        /// <param name="result"></param>
        public static void PrintResult(List<LinkedList<TreeNode>> result)
        {
            var depth = 0;

            foreach (var entry in result)
            {
                var enumerator = entry.GetEnumerator();
                Console.WriteLine("Link list at depth " + depth + ":");

                while (enumerator.MoveNext())
                {
                    if (enumerator.Current != null)
                    {
                        Console.WriteLine(" " + (enumerator.Current.Data));
                    }
                }
                Console.WriteLine();

                depth++;
            }
        }

        #endregion

        #region Soln. 4-3:

        /// <summary>
        /// Method to convert a tree to minimal BST
        /// </summary>
        /// <param name="sortedArray"></param>
        /// <param name="isAscending"></param>
        /// <returns></returns>
        private static TreeNode MinimalBSTFromArr(int[] sortedArray, bool isAscending)
        {
            if (sortedArray == null || sortedArray.Length == 0)
            {
                return null;
            }
            else
            {
                return MinimalBSTFromArr(sortedArray, 0, sortedArray.Length - 1, isAscending);
            }

        }

        /// <summary>
        /// Method to convert a tree to minimal BST
        /// </summary>
        /// <param name="sortedArray"></param>
        /// <param name="startingIndex"></param>
        /// <param name="endingIndex"></param>
        /// <param name="isAscending"></param>
        /// <returns></returns>
        private static TreeNode MinimalBSTFromArr(int[] sortedArray, int startingIndex, int endingIndex, bool isAscending)
        {
            if (endingIndex < startingIndex)
            {
                return null;
            }
            else
            {
                int mid = (startingIndex + endingIndex) / 2;
                TreeNode root = new TreeNode(sortedArray[mid]);

                if (isAscending)
                {
                    root.Left = MinimalBSTFromArr(sortedArray, startingIndex, mid - 1, isAscending);
                    root.Right = MinimalBSTFromArr(sortedArray, mid + 1, endingIndex, isAscending);
                }
                else
                {
                    root.Right = MinimalBSTFromArr(sortedArray, startingIndex, mid - 1, isAscending);
                    root.Left = MinimalBSTFromArr(sortedArray, mid + 1, endingIndex, isAscending);
                }

                return root;
            }
        }

        #endregion

        #region Soln 4-2:

        /// <summary>
        /// Enumeration for visiting states of graph nodes
        /// </summary>
        public enum VisitStatus
        {
            Visiting = 1,
            Unvisited = 2,
            Visited = 3,
        }

        /// <summary>
        /// Graph Node 
        /// </summary>
        public class Node1
        {
            public VisitStatus Status;
            public string Vertex;
            public List<Node1> AdjacentNodes;

            //Should be a constant
            private const int magicMaxAdjacentCount = 100;

            /// <summary>
            /// Constructor
            /// </summary>
            /// <param name="data"></param>
            public Node1(string data)
            {
                Vertex = data;
                Status = VisitStatus.Unvisited;
                AdjacentNodes = new List<Node1>();
            }

            /// <summary>
            /// Add a new adjacent node, not allowed if number of adjacent nodes is already 100
            /// </summary>
            /// <param name="node"></param>
            public void AddAdjacentNode(Node1 node)
            {
                if (AdjacentNodes.Count >= magicMaxAdjacentCount)
                {
                    Console.WriteLine("Max adjacent node count reached");
                    return;
                }
                else
                {
                    AdjacentNodes.Add(node);
                }
            }
        }

        /// <summary>
        /// Graph
        /// </summary>
        public class Graph
        {
            public List<Node1> Nodes;

            //Should be a constant
            private const int magicMaxNodeCount = 300;
            private int v;
            private int e;

            /// <summary>
            /// Constructor
            /// </summary>
            public Graph()
            {
                Nodes = new List<Node1>();
            }

            public Graph(int v, int e)
            {
                this.v = v;
                this.e = e;
            }

            /// <summary>
            /// Add node to the graph
            /// </summary>
            /// <param name="node"></param>
            public void AddNode(Node1 node)
            {
                if (Nodes.Count >= magicMaxNodeCount)
                {
                    Console.WriteLine("Max Node count reached in graph");
                }
                else
                {
                    Nodes.Add(node);
                }
            }
        }

        /// <summary>
        /// Find path between two given node in a graph
        /// </summary>
        /// <param name="graph"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="longDistance"></param>
        /// <returns></returns>
        public static bool FindPathInGraph(Graph graph, Node1 start, Node1 end, bool longDistance)
        {
            if (graph == null || start == null || end == null)
            {
                return false;
            }
            //BFS
            else if (!longDistance)
            {
                //Reset all nodes visiting status
                ResetVisitStatus(graph);

                start.Status = VisitStatus.Visiting;
                var tempList = new List<Node1>();
                tempList.Add(start);

                while (tempList.Count != 0)
                {
                    var unvisited = tempList[0];
                    tempList.RemoveAt(0);

                    if (unvisited != null)
                    {
                        foreach (var item in unvisited.AdjacentNodes)
                        {
                            if (item.Status == VisitStatus.Unvisited)
                            {
                                if (item == end)
                                {
                                    return true;
                                }
                                else
                                {
                                    item.Status = VisitStatus.Visiting;
                                    tempList.Add(item);
                                }
                            }

                            item.Status = VisitStatus.Visited;
                        }
                    }
                }

                return false;
            }
            //DFS
            else
            {
                start.Status = VisitStatus.Visiting;

                foreach (var item in start.AdjacentNodes)
                {
                    if (item.Status == VisitStatus.Unvisited)
                    {
                        if (item == end)
                        {
                            return true;
                        }
                        else
                        {
                            item.Status = VisitStatus.Visiting;
                            if (FindPathInGraph(graph, item, end, longDistance))
                                return true;
                        }
                    }

                    item.Status = VisitStatus.Visited;
                }

                return false;
            }
        }

        /// <summary>
        /// Method to reset the visit status
        /// </summary>
        /// <param name="graph"></param>
        private static void ResetVisitStatus(Graph graph)
        {
            foreach (var item in graph.Nodes)
            {
                item.Status = VisitStatus.Unvisited;
            }
        }

        /// <summary>
        /// Sample Test data
        /// </summary>
        /// <returns></returns>
        public static Graph CreateNewGraph()
        {
            var graph = new Graph();
            var nodes = new Node1[10];

            nodes[0] = new Node1("a");
            nodes[1] = new Node1("b");
            nodes[2] = new Node1("c");
            nodes[3] = new Node1("d");
            nodes[4] = new Node1("e");
            nodes[5] = new Node1("f");
            nodes[6] = new Node1("g");
            nodes[7] = new Node1("h");
            nodes[8] = new Node1("i");
            nodes[9] = new Node1("j");

            nodes[0].AddAdjacentNode(nodes[1]);
            nodes[0].AddAdjacentNode(nodes[2]);
            nodes[1].AddAdjacentNode(nodes[3]);
            nodes[2].AddAdjacentNode(nodes[4]);
            nodes[3].AddAdjacentNode(nodes[4]);
            nodes[3].AddAdjacentNode(nodes[6]);
            nodes[4].AddAdjacentNode(nodes[5]);
            nodes[6].AddAdjacentNode(nodes[7]);
            nodes[6].AddAdjacentNode(nodes[9]);
            nodes[7].AddAdjacentNode(nodes[8]);
            nodes[8].AddAdjacentNode(nodes[9]);

            for (var i = 0; i < 10; i++)
            {
                graph.AddNode(nodes[i]);
            }

            return graph;
        }

        #endregion

        #region Soln. 4-1:

        /// <summary>
        /// Check if tree is balanced
        /// </summary>
        /// <param name="node"></param>
        /// <returns>true if height diff is less or equals to 1</returns>
        public static bool IsBalanced(TreeNode node)
        {
            if (CheckHeight(node) == -1)
            {
                return false;
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// Calculate height of the tree
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        private static int CheckHeight(TreeNode node)
        {
            if (node == null)
            {
                return 0;
            }
            else
            {
                //Check left node
                var leftHeight = CheckHeight(node.Left);
                if (leftHeight == -1)
                {
                    return -1;
                }

                //Check right node
                var rightHeight = CheckHeight(node.Right);
                if (rightHeight == -1)
                {
                    return -1;
                }

                //check the diffrence of heights
                if (Math.Abs(leftHeight - rightHeight) > 1)
                {
                    return -1;
                }
                else
                {
                    return Math.Max(leftHeight, rightHeight) + 1;
                }
            }
        }
        #endregion

        #region Soln. 3-7:

        public abstract class Animal
        {
            protected int order;
            protected string name;

            public Animal(string name)
            {
                this.name = name;
            }

            public abstract string GetName();

            public int Order
            {
                get
                {
                    return this.order;
                }
                set
                {
                    this.order = value;
                }
            }

            public bool IsOlderThan(Animal animal)
            {
                return this.order < animal.order;
            }

        }

        public class Cat : Animal
        {
            public override string GetName()
            {
                return string.Format("Cat: {0}", this.name);
            }

            public Cat(string name) : base(name)
            { }
        }

        public class Dog : Animal
        {
            public Dog(string name) : base(name)
            { }

            public override string GetName()
            {
                return string.Format("Dog: {0}", this.name);
            }
        }

        public class AnimalQueue
        {
            readonly List<Cat> cats = new List<Cat>();
            readonly List<Dog> dogs = new List<Dog>();
            int order;

            public AnimalQueue()
            {
                order = 0;
            }

            public void Enqueue(Animal animal)
            {
                if (animal == null)
                {
                    return;
                }
                else
                {
                    animal.Order = order++;

                    if (animal.GetType().Equals(typeof(Dog)))
                    {
                        dogs.Add((Dog)animal);
                    }
                    else if (animal.GetType().Equals(typeof(Cat)))
                    {
                        cats.Add((Cat)animal);
                    }
                    else
                        return;
                }
            }

            public Animal DequeueAny()
            {
                if (dogs.Count == 0 && cats.Count == 0)
                {
                    return null;
                }
                else if (dogs.Count == 0)
                {
                    return DequeueCat();
                }
                else if (cats.Count == 0)
                {
                    return DequeueDog();
                }
                else
                {
                    var dog = dogs[0];
                    var cat = cats[0];

                    if (dog.IsOlderThan(cat))
                    {
                        dogs.RemoveAt(0);
                        return dog;
                    }
                    else
                    {
                        cats.RemoveAt(0);
                        return cat;
                    }
                }
            }

            public Cat DequeueCat()
            {
                if (cats.Count == 0)
                {
                    return null;
                }
                else
                {
                    var cat = cats[0];
                    cats.RemoveAt(0);
                    return cat;
                }
            }

            public Dog DequeueDog()
            {
                if (dogs.Count == 0)
                {
                    return null;
                }
                else
                {
                    var dog = dogs[0];
                    dogs.RemoveAt(0);
                    return dog;
                }
            }

            public Animal Peek()
            {
                if (dogs.Count == 0)
                {
                    return cats[0];
                }
                else if (cats.Count == 0)
                {
                    return dogs[0];
                }

                var dog = dogs[0];
                var cat = cats[0];

                if (dog.IsOlderThan(cat))
                {
                    return dog;
                }
                else
                {
                    return cat;
                }
            }

            public Cat PeekCats()
            {
                return cats[0];
            }

            public Dog PeekDogs()
            {
                return dogs[0];
            }

            public int Count()
            {
                return cats.Count + dogs.Count;
            }
        }

        #endregion

        #region Soln. 3-6:

        private static Stack<int> SortStack(Stack<int> stack)
        {
            Stack<int> stack2 = new Stack<int>();

            while (stack.Count != 0)
            {
                int temp = stack.Pop();

                while (stack2.Count != 0 && stack2.Peek() > temp)
                {
                    stack.Push(stack2.Pop());
                }

                stack2.Push(temp);
            }

            return stack2;
        }


        private static Stack<int> MergeSortStack(Stack<int> stack)
        {
            if (stack.Count <= 1)
            {
                return stack;
            }
            else
            {
                var left = new Stack<int>();
                var right = new Stack<int>();
                int counter = 0;

                //divide the stack in left and right
                while (stack.Count != 0)
                {
                    if (counter % 2 == 0)
                    {
                        left.Push(stack.Pop());
                    }
                    else
                    {
                        right.Push(stack.Pop());
                    }
                    counter++;
                }

                //already divided, now sort recursively
                left = MergeSortStack(left);
                right = MergeSortStack(right);

                //now merge back
                while (left.Count != 0 || right.Count != 0)
                {
                    if (left.Count == 0)
                    {
                        stack.Push(right.Pop());
                    }
                    else if (right.Count == 0)
                    {
                        stack.Push(left.Pop());
                    }
                    else if (left.Peek() > right.Peek())
                    {
                        stack.Push(left.Pop());
                    }
                    else
                    {
                        stack.Push(right.Pop());
                    }
                }

                //return stack;

                var returningStack = new Stack<int>();

                while (stack.Count != 0)
                {
                    returningStack.Push(stack.Pop());
                }

                return returningStack;

            }
        }

        #endregion

        #region Soln. 3-5:

        public class MyQueue<T>
        {
            private Stack<T> oldStack, newStack;

            public MyQueue()
            {
                oldStack = new Stack<T>();
                newStack = new Stack<T>();
            }

            /// <summary>
            /// Enqueue
            /// </summary>
            public void Enqueue(T data)
            {
                newStack.Push(data);
            }

            /// <summary>
            /// Dequeue
            /// </summary>
            /// <returns></returns>
            public T Dequeue()
            {
                if (oldStack.Count != 0)
                {
                    return oldStack.Pop();
                }
                else if (newStack.Count != 0)
                {
                    while (newStack.Count != 0)
                    {
                        oldStack.Push(newStack.Pop());
                    }

                    return oldStack.Pop();
                }
                else
                {
                    throw new InvalidOperationException("Queue is empty.");
                }
            }

            /// <summary>
            /// Peek
            /// </summary>
            /// <returns></returns>
            public T Peek()
            {
                //return if old stack is not empty
                if (oldStack.Count != 0)
                {
                    return oldStack.Peek();
                }
                //if old stack is empty, then pop out the entire new stack to old and then return top element
                else if (newStack.Count != 0)
                {
                    while (newStack.Count != 0)
                    {
                        oldStack.Push(newStack.Pop());
                    }

                    return oldStack.Peek();
                }
                //if both stacks are empty, then throw invalid operation exception
                else
                {
                    throw new InvalidOperationException("Queue is empty.");
                }
            }

            /// <summary>
            /// Count
            /// </summary>
            /// <returns></returns>
            public int Count()
            {
                return newStack.Count + oldStack.Count;
            }
        }



        #endregion

        #region Soln. 3-4:

        //DebuggerDisplay("Label = {Label}")]
        public class Tower
        {
            public string Label { get; set; }

            readonly Stack<int> _disks;
            private int Index { get; set; }

            public Tower(int index)
            {
                _disks = new Stack<int>();
                Index = index;
            }

            public void Add(int disk)
            {
                if (_disks.Count != 0 && _disks.Peek() <= disk)
                {
                    Console.WriteLine("Error placing disk " + disk);
                }
                else
                {
                    _disks.Push(disk);
                }
            }

            public void MoveTopTo(Tower tower)
            {
                var top = _disks.Pop();
                tower.Add(top);
            }

            public void Print()
            {
                var sb = new StringBuilder();

                foreach (var disk in _disks)
                {
                    sb.AppendFormat("{0},", disk);
                }

                if (sb.Length != 0)
                {
                    sb.Remove(sb.Length - 1, 1);
                }

                Console.WriteLine("Contents of Tower " + Index + ": " + sb);
            }

            public void MoveDisks(int n, Tower destination, Tower buffer)
            {
                if (n > 0)
                {
                    Print();
                    buffer.Print();
                    destination.Print();
                    Console.WriteLine();
                    MoveDisks(n - 1, buffer, destination);
                    Print();
                    buffer.Print();
                    destination.Print();
                    Console.WriteLine();
                    MoveTopTo(destination);
                    Print();
                    buffer.Print();
                    destination.Print();
                    Console.WriteLine();
                    buffer.MoveDisks(n - 1, destination, this);
                    Print();
                    buffer.Print();
                    destination.Print();
                    Console.WriteLine();
                }
            }
        }

        #endregion

        #region Soln 3-3:

        /// <summary>
        /// Node class.
        /// </summary>
        public class Node
        {
            public Node Above, Below;
            public int Data;

            public Node(int value)
            {
                this.Data = value;
            }
        }

        /// <summary>
        /// CLass for Plates
        /// </summary>
        public class StackPlates
        {
            public Node Top, Bottom;
            public int Size;
            readonly public int Capacity;


            public StackPlates(int capacity)
            {
                this.Capacity = capacity;
                this.Size = 0;
            }


            public bool IsFull()
            {
                return this.Size == this.Capacity;
            }


            public void Join(Node above, Node below)
            {
                if (above != null)
                {
                    above.Below = below;
                }

                if (below != null)
                {
                    below.Above = above;
                }
            }


            public bool Push(int value)
            {
                if (IsFull())
                {
                    return false;
                }
                else
                {
                    Size++;
                    var node = new Node(value);
                    if (this.Size == 1)
                    {
                        this.Bottom = node;
                    }
                    Join(node, Top);
                    this.Top = node;
                    return true;
                }
            }


            public int Pop()
            {
                var top = this.Top;
                this.Top = this.Top.Below;
                this.Size--;

                return top.Data;
            }


            public bool IsEmpty()
            {
                return this.Size == 0;
            }


            public int RemoveBottom()
            {
                var bottom = this.Bottom;
                this.Bottom = this.Bottom.Above;

                if (this.Bottom != null)
                {
                    this.Bottom.Below = null;
                }
                this.Size--;

                return bottom.Data;
            }

            public int Peek()
            {
                return this.Top.Data;
            }
        }

        /// <summary>
        /// Class for SetOfStacks
        /// </summary>
        public class SetOfStacks
        {
            private readonly List<StackPlates> stacks = new List<StackPlates>();
            private int capacity;

            public StackPlates GetLastStack()
            {
                if (stacks.Count == 0)
                {
                    return null;
                }
                else
                {
                    return stacks[stacks.Count - 1];
                }
            }

            public int GetCapacity()
            {
                return capacity;
            }

            public SetOfStacks(int capacity)
            {
                this.capacity = capacity;
            }

            public void Push(int data)
            {
                var last = GetLastStack();

                if (last != null && !last.IsFull())
                {
                    last.Push(data);
                }
                else
                {
                    var tempStack = new StackPlates(GetCapacity());
                    tempStack.Push(data);
                    stacks.Add(tempStack);
                }
            }

            public int Pop()
            {
                var last = GetLastStack();
                var data = last.Pop();

                if (last.IsEmpty())
                {
                    stacks.Remove(last);
                }

                return data;
            }

            public int Peek()
            {
                return GetLastStack().Peek();
            }

            public int PopAt(int stackIndex)
            {
                return LeftShift(stackIndex, true);
            }

            private int LeftShift(int stackIndex, bool removeTop)
            {
                var stack = stacks[stackIndex];
                var data = (removeTop) ? stack.Pop() : stack.RemoveBottom();

                if (stack.IsEmpty())
                {
                    stacks.Remove(stack);
                }
                else if (stacks.Count > stackIndex + 1)
                {
                    stack.Push(LeftShift(stackIndex + 1, false));
                }

                return data;
            }

            public int Count()
            {
                return stacks.Count;
            }

            public bool IsEmpty()
            {
                var last = GetLastStack();
                return last == null || last.IsEmpty();
            }

            public void PushAt(int index, int data)
            {
                stacks[index].Push(data);
            }
        }

        #endregion

        #region Soln. 3-2:

        public class StackWithMin
        {
            private Stack<int> stack = new Stack<int>();
            private Stack<int> min = new Stack<int>();

            /// <summary>
            /// Construtor
            /// </summary>
            /// <param name="value"></param>
            /// <param name="min"></param>
            public StackWithMin(int value)
            {
                stack.Push(value);

                //check if min is less than current minimum or not
                if (value < Min())
                {
                    //if yes, then push
                    this.min.Push(value);
                }
            }

            /// <summary>
            /// Method to get the minimum value
            /// </summary>
            /// <returns></returns>
            public int Min()
            {
                if (this.min.Count == 0)
                {
                    //if min stack is empty
                    return int.MaxValue;
                }
                else
                {
                    return this.min.Peek();
                }
            }

            /// <summary>
            /// Peek method
            /// </summary>
            /// <returns></returns>
            public int Peek()
            {
                return this.stack.Peek();
            }

            /// <summary>
            /// Puch method
            /// </summary>
            /// <param name="value"></param>
            public void Push(int value)
            {
                this.stack.Push(value);

                //check if current value is minimum
                if (value < Min())
                {
                    //then Push in min stack too
                    this.min.Push(value);
                }
            }

            /// <summary>
            /// Pop method
            /// </summary>
            /// <returns></returns>
            public int Pop()
            {
                var value = this.stack.Pop();

                //chekc if current value is minimum
                if (value == Min())
                {
                    //then Pop is min stack too
                    this.min.Pop();
                }

                return value;
            }
        }


        #endregion

        #region Soln. 3-1:

        private static int TotalStackSize()
        {
            return Stacks[0].size + Stacks[1].size + Stacks[2].size;
        }

        private static int NextIndex(int index)
        {
            if (index + 1 == TotalSize)
            {
                return 0;
            }
            else
            {
                return index + 1;
            }
        }

        private static int PreviousIndex(int index)
        {
            if (index == 0)
            {
                return TotalSize - 1;
            }
            else
            {
                return index - 1;
            }
        }

        private static bool IsEmpty(int stackNumber)
        {
            return Stacks[stackNumber].size == 0;
        }

        public static int Peek(int stackNumber)
        {
            if (IsEmpty(stackNumber))
            {
                throw new InvalidOperationException("Stack is empty, Peeking not alowed");
            }

            return Buffer[Stacks[stackNumber].pointer];
        }

        public static int Pop(int stackNumber)
        {
            if (IsEmpty(stackNumber))
            {
                throw new InvalidOperationException("Stack is empty, Peeking not alowed");
            }

            var value = Buffer[Stacks[stackNumber].pointer];
            Buffer[Stacks[stackNumber].pointer] = 0;
            Stacks[stackNumber].pointer = PreviousIndex(Stacks[stackNumber].pointer);
            Stacks[stackNumber].size--;

            return value;
        }

        public static void Push(int stackNumber, int value)
        {
            var stack = Stacks[stackNumber];

            if (stack.size >= stack.capacity)
            {
                if (TotalStackSize() >= TotalSize)
                {
                    throw new Exception("Totally out of caacity, can't Push anymore.");
                }
                else
                {
                    Expand(stackNumber);
                }
            }

            stack.size++;
            stack.pointer = NextIndex(stack.pointer);
            Buffer[stack.pointer] = value;
        }

        private static void Expand(int stackNumber)
        {
            Shift((stackNumber + 1) % NumberOfStacks);
            Stacks[stackNumber].capacity++;
        }

        private static void Shift(int stackNumber)
        {
            var stack = Stacks[stackNumber];

            if (stack.size >= stack.capacity)
            {
                var nextStack = (stackNumber + 1) % NumberOfStacks;
                Shift(nextStack); // make some room
                stack.capacity++;
            }

            for (var index = (stack.start + stack.capacity - 1) % TotalSize; // end of array
                          stack.IsWithinStack(index, TotalSize);
                          index = PreviousIndex(index))
            {
                Buffer[index] = Buffer[PreviousIndex(index)];
            }

            Buffer[stack.start] = 0;
            stack.start = NextIndex(stack.start); // move start start
            stack.pointer = NextIndex(stack.pointer); // move stack pointer
            stack.capacity--; // return capacity to original
        }

        #endregion

        #region Soln. 2-7:

        private static bool IsListPalindrome(LinkedListNode list)
        {
            Solution27 result = CheckList(list, GetListLength(list));
            return result.result;
        }


        private static bool IsListPalindromeNonRecursive(LinkedListNode list)
        {
            var slow = list;
            var fast = list;
            var stack1 = new Stack<int>();

            //find half-way or almost
            while (fast != null && fast.Next != null)
            {
                stack1.Push(slow.Data);
                slow = slow.Next;
                fast = fast.Next.Next;
            }

            //if odd, ignore middle element
            if (fast != null)
            {
                slow = slow.Next;
            }

            while (slow != null)
            {
                if (slow.Data != stack1.Pop())
                {
                    return false;
                }

                slow = slow.Next;
            }

            return true;
        }
        private static Solution27 CheckList(LinkedListNode list, long Length)
        {
            if (list == null || Length == 0)
            {
                return new Solution27(null, true);
            }
            else if (Length == 1)
            {
                return new Solution27(list.Next, true);
            }
            else if (Length == 2)
            {
                return new Solution27(list.Next.Next, (list.Next.Data == list.Next.Next.Data));
            }
            else
            {
                var result = CheckList(list.Next, Length - 2);

                if (result.value == null || !result.result)
                {
                    return result;
                }
                else
                {
                    result.result = list.Data == result.value.Data;
                    result.value = result.value.Next;

                    return result;
                }

            }
        }

        #endregion

        #region Soln. 2-6:

        private static LinkedListNode FindCircularHead(LinkedListNode list)
        {
            var slow = list;
            var fast = list;

            //find the meeting point
            while (fast != null && fast.Next != null)
            {
                slow = slow.Next;
                fast = fast.Next.Next;

                if (fast == slow)
                {
                    break;
                }
            }

            //errorcheck
            if (fast == null || fast.Next == null)
            {
                return null;
            }

            //point slow to start and move both pointers one node at time, so that they meet at th beginning
            slow = list;
            while (slow != fast)
            {
                slow = slow.Next;
                fast = fast.Next;
            }

            return fast;
        }

        #endregion

        #region Soln. 2-5:

        private static LinkedListNode GetSum(LinkedListNode list1, LinkedListNode list2, bool isInForwardOrder)
        {
            if (isInForwardOrder)
            {
                return GetSum(ReverseList(list1, true), ReverseList(list2, true), 0);
            }

            return GetSum(list1, list2, 0);
        }

        private static LinkedListNode GetSum(LinkedListNode list1, LinkedListNode list2, int carry)
        {
            if (list1 == null && list2 == null && carry == 0)
            {
                return null;
            }
            else if (list1 == null && list2 == null && carry == 1)
            {
                return new LinkedListNode(1, null, null);
            }
            else
            {
                LinkedListNode sum = new LinkedListNode();
                var value = carry;

                if (list1 != null)
                {
                    value += list1.Data;
                }

                if (list2 != null)
                {
                    value += list2.Data;
                }

                sum.Data = value % 10;

                if (list1 != null || list2 != null)
                {
                    var more = GetSum(list1 == null ? null : list1.Next, list2 == null ? null : list2.Next, value >= 10 ? 1 : 0);
                    sum.Next = more;
                }

                return sum;
            }
        }

        /// <summary>
        /// Get linked list Length
        /// </summary>
        /// <param name="list"></param>
        /// <returns></returns>
        private static long GetListLength(LinkedListNode list)
        {
            if (list == null)
            {
                return 0;
            }
            else if (list.Next == null)
            {
                return 1;
            }
            else
            {
                return GetListLength(list.Next) + 1;
            }
        }

        /// <summary>
        /// Reverse a Linked List in O(n)
        /// </summary>
        /// <param name="list"></param>
        /// <param name="clone"></param>
        /// <returns></returns>
        private static LinkedListNode ReverseList(LinkedListNode list, bool clone)
        {
            if (list == null)
            {
                return null;
            }
            else
            {
                LinkedListNode next = null;
                LinkedListNode prev = null;
                LinkedListNode current = null;

                if (clone)
                {
                    current = list.Clone();
                }
                else
                {
                    current = list;
                }

                while (current != null)
                {
                    next = current.Next;
                    current.Next = prev;
                    prev = current;
                    current = next;
                }

                return prev;
            }
        }

        /// <summary>
        /// Reverse a Linked List in recursive manner
        /// </summary>
        /// <param name="list"></param>
        /// <returns></returns>
        private static LinkedListNode ReverseListRecurse(LinkedListNode list)
        {
            if (list == null || list.Next == null)
            {
                return list;
            }
            else
            {
                var temp = ReverseListRecurse(list.Next);
                list.Next.Next = list;
                list.Next = null;

                return temp;
            }
        }

        #endregion

        #region AMZ Online Prob
        /// <summary>
        /// Add one to the last element of the linked list
        /// </summary>
        /// <param name="ip1"></param>
        /// <returns></returns>
        private static int[] AddOne(int[] ip1)
        {
            return GetArrayFromInt(GetIntFromArray(ip1) + 1);
        }

        private static int[] GetArrayFromInt(int value)
        {
            int[] res = new int[string.Format("{0}", value).Length];

            for (int count = res.Length - 1; count >= 0; count--)
            {
                res[count] = value % 10;
                value /= 10;
            }

            return res;
        }

        private static int GetIntFromArray(int[] ip1)
        {
            int result = 0;

            for (int count = 0; count < ip1.Length; count++)
            {
                result += ip1[count];
                if (count < ip1.Length - 1)
                {
                    result *= 10;
                }
            }

            return result;
        }

        #endregion

        #region Soln. 2-4:

        private static LinkedListNode Partition(LinkedListNode node, int pivot)
        {
            LinkedListNode leftList = new LinkedListNode(); // empty temp node to not have an IF inside the loop
            LinkedListNode rightList = new LinkedListNode(pivot, null, null);

            LinkedListNode leftListHead = leftList; // Used at the end to remove the empty node.
            LinkedListNode rightListHead = rightList; // Used at the end to merge lists.

            var currentNode = node;

            while (currentNode != null)
            {
                if (currentNode.Data < pivot)
                {
                    leftList = new LinkedListNode(currentNode.Data, null, leftList);
                }
                else if (currentNode.Data >= pivot)
                {
                    rightList = new LinkedListNode(currentNode.Data, null, rightList);
                }

                currentNode = currentNode.Next;
            }

            leftList.Next = rightListHead;

            var finalList = leftListHead.Next;
            leftListHead.Next = null; // remove the temp node, GC will release the mem

            return finalList;
        }

        #endregion

        #region Soln. 2-3:
        private static LinkedListNode SortLinkedList(LinkedListNode head)
        {
            for (LinkedListNode list = head; list.Next != null; list = list.Next)
            {
                for (LinkedListNode pass = list.Next; pass != null; pass = pass.Next)
                {
                    if (list.Data > pass.Data)
                    {
                        Console.WriteLine("Swap:{0} with:{1}", list.Data, pass.Data);
                        var temp = list.Data;
                        list.Data = pass.Data;
                        pass.Data = temp;
                    }
                }
            }
            return head;
        }
        #endregion

        #region Soln. 2-2:

        private static LinkedListNode NthToLast(LinkedListNode head, int value)
        {
            if (head == null)
            {
                return null;
            }

            LinkedListNode node1 = head;
            LinkedListNode node2 = head;

            for (int counter = 0; counter < value - 1; counter++)
            {
                node2 = node2.Next;
            }

            while (node2 != null)
            {
                node1 = node1.Next;
                node2 = node2.Next;
            }

            return node1;
        }


        #endregion

        #region Slon. 2-1:

        private static void DeleteDups(LinkedListNode head)
        {
            if (head == null)
            {
                return;
            }
            else
            {
                LinkedListNode current = head;

                while (current != null)
                {
                    var runner = current;

                    while (runner.Next != null)
                    {
                        if (runner.Next.Data == current.Data)
                        {
                            runner.Next = runner.Next.Next;
                        }
                        else
                        {
                            runner = runner.Next;
                        }
                    }

                    current = current.Next;
                }
            }
        }

        #endregion

        #region Soln 1-last:

        /// <summary>
        /// Method to find rotation
        /// </summary>
        /// <param name="original"></param>
        /// <param name="rotated"></param>
        /// <returns></returns>
        private static bool IsRotation(string original, string rotated)
        {
            if (string.IsNullOrEmpty(original) || string.IsNullOrEmpty(rotated))
            {
                return false;
            }
            else if (original.Length != rotated.Length)
            {
                return false;
            }
            else
            {
                return IsSubstring(original + original, rotated);
            }
        }

        /// <summary>
        /// Substring method
        /// </summary>
        /// <param name="main"></param>
        /// <param name="sub"></param>
        /// <returns></returns>
        private static bool IsSubstring(string main, string sub)
        {
            return main.IndexOf(sub) >= 0;
        }

        #endregion

        #region Sloution 1-6:
        /// <summary>
        /// Method to rotate matrix
        /// </summary>
        /// <param name="matrix"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        private static int[,] RotateMatrix(int[,] matrix, int value)
        {
            if (value <= 0 || null == matrix)
            {
                Console.WriteLine("Inavlid input.");
                return null;
            }
            else
            {
                for (int layer = 0; layer < value / 2; ++layer)
                {
                    var first = layer;
                    var last = value - 1 - layer;

                    for (int counter = first; counter < last; ++counter)
                    {
                        int offset = counter - first;

                        //Top to temp
                        var temp = matrix[first, counter];

                        //Left to top
                        matrix[first, counter] = matrix[last - offset, first];

                        //Bottom to left
                        matrix[last - offset, first] = matrix[last, last - offset];

                        //Right to bottom
                        matrix[last, last - offset] = matrix[counter, last];

                        //Temp to right
                        matrix[counter, last] = temp;
                    }
                }

                return matrix;
            }
        }

        /// <summary>
        /// Rectangular matrix
        /// </summary>
        /// <param name="matrix"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        private static int[,] RotateMatrix2(int[,] matrix, int Length, int width)
        {
            if (Length <= 0 || width <= 0 || null == matrix)
            {
                Console.WriteLine("Inavlid input.");
                return null;
            }
            else
            {
                int[,] matrix2 = new int[width, Length];

                for (int counter1 = 0; counter1 < Length; counter1++)
                {
                    for (int counter2 = 0; counter2 < width; counter2++)
                    {
                        matrix2[counter2, counter1] = matrix[counter1, counter2];
                    }
                }

                return matrix2;
            }
        }
        #endregion

        #region Solution 1-5:
        /// <summary>
        /// Method to compress string
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        private static string Compressstring(char[] input)
        {
            if (string.IsNullOrEmpty(input.ToString()))
            {
                return string.Empty;
            }

            int compressedSize = CompressstringLength(input);
            if (compressedSize >= input.Length)
            {
                return new string(input);
            }
            else
            {
                char[] compressedStr = new char[compressedSize];
                var count = 1;
                var index = 0;
                var last = input[0];

                for (int counter = 1; counter < input.Length; counter++)
                {
                    if (last.Equals(input[counter]))
                    {
                        count++;
                    }
                    else
                    {
                        index = SetChars(compressedStr, count, index, last);
                        last = input[counter];
                        count = 1;
                    }
                }

                SetChars(compressedStr, count, index, last);

                return new string(compressedStr);
            }
        }

        /// <summary>
        /// Method to set chars after finding a non-matching one
        /// </summary>
        /// <param name="compressedStr"></param>
        /// <param name="count"></param>
        /// <param name="index"></param>
        /// <param name="last"></param>
        private static int SetChars(char[] compressedStr, int count, int index, char last)
        {
            compressedStr[index] = last;
            index++;

            char[] cnt = count.ToString().ToCharArray();
            foreach (var number in cnt)
            {
                compressedStr[index] = number;
                index++;
            }

            return index;
        }

        /// <summary>
        /// Method to find out the compressed string Length
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        private static int CompressstringLength(char[] input)
        {
            var last = input[0];
            var count = 1;
            var Length = 0;

            for (int counter = 1; counter < input.Length; counter++)
            {
                if (input[counter].Equals(last))
                {
                    count++;
                }
                else
                {
                    last = input[counter];
                    Length += 1 + string.Format("{0}", count).Length;
                    count = 1;
                }
            }

            Length += 1 + string.Format("{0}", count).Length;

            return Length;
        }
        #endregion

        #region Solution 1-4:
        /// <summary>
        /// Method to do an inplace character replacing in an char-array
        /// </summary>
        /// <param name="originalChars"></param>
        /// <param name="char2Replace"></param>
        /// <param name="replacingChars"></param>
        /// <param name="Length"></param>
        /// <returns></returns>
        private static char[] ReplaceInplaceChars(char[] originalChars, char char2Replace, char[] replacingChars, int Length)
        {
            if (null == originalChars || null == replacingChars || originalChars.Length == 0 || replacingChars.Length == 0)
            {
                Console.WriteLine("Invalid input");
                return new char[0];
            }

            int charCount = 0;

            for (int counter = 0; counter < Length; counter++)
            {
                if (originalChars[counter].Equals(char2Replace))
                {
                    charCount++;
                }
            }

            int index = Length + (replacingChars.Length - 1) * charCount;

            for (int counter = Length - 1; counter >= 0; counter--)
            {
                if (originalChars[counter].Equals(char2Replace))
                {
                    for (int counter2 = replacingChars.Length - 1, counter3 = 1; counter2 >= 0; counter2--, counter3++)
                    {
                        originalChars[index - counter3] = replacingChars[counter2];
                    }
                    index -= replacingChars.Length;
                }
                else
                {
                    originalChars[index - 1] = originalChars[counter];
                    index--;
                }
            }

            return originalChars;
        }
        #endregion

        #region FindTriplets
        /// <summary>
        /// Method to get a^2 + b^2 = c^2 triplet sin as array.
        /// </summary>
        /// <param name="array"></param>
        private static void FindTripletsType01(double[] array)
        {
            if (array.Length < 3)
            {
                Console.WriteLine("Invalid array, should be at least 3 items present.");
                return;
            }

            for (int counter1 = 0; counter1 < array.Length; counter1++)
            {
                for (int counter2 = counter1 + 1; counter2 < array.Length; counter2++)
                {
                    var sqrtVal = Math.Sqrt((array[counter1] * array[counter1]) + (array[counter2] * array[counter2]));
                    if (new List<double>(array).Contains(sqrtVal))
                    {
                        Console.WriteLine("Triplets: {0}, {1}, {2}...", array[counter1], array[counter2], sqrtVal);
                    }
                }
            }
        }
        #endregion

        #region Solution 1-2:

        /// <summary>
        /// Unasfe method to Reverse a null terminated string
        /// </summary>
        /// <param name="text"></param>
        /// <returns></returns>
        public static unsafe string Reverse(string text)
        {
            int len = text.Length;
            string ReversedText;
            var temp = new char[len - 1];

            //Use this if string is short to medium in Length
            //char* Reversed = stackalloc char[len];      

            //Use this if string is larger.
            fixed (char* Reversed = &temp[0])
            {

                // Avoid bounds-checking performance penalties.
                fixed (char* str = text)
                {
                    int i = 0;
                    int j = i + len - 2;
                    while (i < len - 1)
                    {
                        Reversed[i++] = str[j--];
                    }
                }

                ReversedText = new string(Reversed, 0, len);
            }

            // Need to use this overload for the System.string constructor
            // as providing just the char* pointer could result in garbage
            // at the end of the string (no guarantee of null terminator).
            return ReversedText;
        }

        #endregion

        #region Solution 1-1:
        /// <summary>
        /// Solution 1-1...
        /// </summary>
        private static void CheckUniqueSoln()
        {

            try
            {
                Console.Write("Please provide input: ");
                var input = Console.ReadLine();

                char[] chars = input.Trim().ToCharArray();
                Console.WriteLine("Input characters:");
                foreach (var character in chars)
                {
                    Console.WriteLine(character);
                }

                //if (EasyCheckUnique(chars))
                if (BetterCheckUnique(chars))
                {
                    Console.WriteLine("All unique chars...");
                }
                else
                {
                    Console.WriteLine("All are not unique...");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }

        }

        /// <summary>
        /// Easy method to check unique characters
        /// </summary>
        /// <param name="chars"></param>
        /// <returns></returns>
        private static bool EasyCheckUnique(char[] chars)
        {
            HashSet<char> charsset = new HashSet<char>();

            for (int counter = 0; counter < chars.Length; counter++)
            {
                if (charsset.Contains(chars[counter]))
                {
                    return false;
                }
                else
                {
                    charsset.Add(chars[counter]);
                }
            }

            return true;
        }

        /// <summary>
        /// Method to check unique string using on an integer.
        /// </summary>
        /// <param name="chars"></param>
        /// <returns></returns>
        private static bool BetterCheckUnique(char[] chars)
        {
            int checker = 0;

            for (int counter = 0; counter < chars.Length; counter++)
            {
                if ((checker & (1 << (chars[counter] - 'a'))) > 0)
                {
                    return false;
                }
                else
                {
                    checker |= (1 << (chars[counter] - 'a'));
                }
            }

            return true;
        }
        #endregion

        #region Solution 77-7

        /// <summary>
        /// 
        /// </summary>
        /// <param name="number"></param>
        /// <returns></returns>
        public static string NumToPhrase(long number)
        {
            string returningStr = string.Empty;

            //if zero or negetive
            if (number == 0)
            {
                return "zero";
            }
            else if (number < 0)
            {
                return string.Format("negetive {0}", number);
            }

            int count = 0;

            while (number > 0)
            {
                //Bigs
                if (number % 1000 != 0)
                {
                    returningStr = string.Format("{0} {1} ", NumToPhrase100(number % 1000), bigs[count]) + returningStr;
                }

                number /= 1000;
                count++;
            }

            return returningStr;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        private static string NumToPhrase100(long value)
        {
            string str = string.Empty;

            //Hundreds
            if (value > 100)
            {
                str += string.Format("{0} hundred ", ones[value / 100 - 1]);
                value %= 100;
            }

            //Teens
            if (value > 11 && value < 19)
            {
                return str += string.Format("{0} ", teens[value - 11]);
            }
            //Tens
            else if (value == 10 || value >= 20)
            {
                str += string.Format("{0} ", tens[value / 10 - 1]);
                value %= 10;
            }

            //Digits
            if (value > 0 && value < 10)
            {
                str += string.Format("{0}", ones[value - 1]);
            }

            return str;
        }

        #endregion

        #region MS Online Probs
        //MS online prob-2:
        public static void MakeTheNumbersMatch(int a, int b, int x, int y)
        {
            while (a != x && b != y)
            {
                if (a > x)
                {
                    a--;
                }
                else
                {
                    a++;
                }
                if (b > y)
                {
                    b--;
                }
                else
                {
                    b++;
                }
            }
        }

        //MS online prob-1:
        private static void PrintVertical(int v)
        {
            Stack<int> test1 = new Stack<int>();
            while (v > 0)
            {
                test1.Push(v % 10);
                v /= 10;
            }

            int Length = test1.Count;
            for (int i = 0; i < Length; i++)
            {
                Console.WriteLine("{0}", test1.Pop().ToString());
            }


        }
        #endregion

        #region Find Duplicate

        /// <summary>
        /// Method to find the repeated element in n+1 Length of array with n distict elements
        /// </summary>
        /// <param name="sourceArr"></param>
        /// <returns></returns>
        public static int FindRepeat(int[] sourceArr)
        {

            int floor = 1;
            int ceiling = sourceArr.Length - 1;

            while (floor < ceiling)
            {

                // divide our range 1..n into an upper range and lower range
                // (such that they don't overlap)
                // lower range is floor..midpoint
                // upper range is midpoint+1..ceiling
                int midpoint = floor + ((ceiling - floor) / 2);
                int lowerRangeFloor = floor;
                int lowerRangeCeiling = midpoint;
                int upperRangeFloor = midpoint + 1;
                int upperRangeCeiling = ceiling;

                // count number of items in lower range
                int itemsInLowerRange = 0;
                foreach (int item in sourceArr)
                {

                    // is it in the lower range?
                    if (item >= lowerRangeFloor && item <= lowerRangeCeiling)
                    {
                        itemsInLowerRange += 1;
                    }
                }

                int distinctPossibleIntegersInLowerRange = lowerRangeCeiling - lowerRangeFloor + 1;

                if (itemsInLowerRange > distinctPossibleIntegersInLowerRange)
                {

                    // there must be a duplicate in the lower range
                    // so use the same approach iteratively on that range
                    floor = lowerRangeFloor;
                    ceiling = lowerRangeCeiling;
                }
                else {

                    // there must be a duplicate in the upper range
                    // so use the same approach iteratively on that range
                    floor = upperRangeFloor;
                    ceiling = upperRangeCeiling;
                }
            }

            // floor and ceiling have converged
            // we found a number that repeats!
            return floor;
        }


        public static int FindDupeAggr(int[] sourceArr)
        {
            if (sourceArr == null || sourceArr.Length < 2)
            {
                throw new Exception("Invalid Array");
            }

            int fastCounter = sourceArr[sourceArr.Length - 1];
            int slowCounter = fastCounter;
            int noLoop = 0;

            do
            {
                slowCounter = sourceArr[slowCounter - 1];
                fastCounter = sourceArr[sourceArr[fastCounter - 1] - 1];

                if (noLoop >= sourceArr.Length)
                {
                    throw new Exception("No Dupe found.");
                }
                else
                    noLoop++;
            }
            while (fastCounter != slowCounter);

            slowCounter = sourceArr[sourceArr.Length - 1];

            while (fastCounter != slowCounter)
            {
                slowCounter = sourceArr[slowCounter - 1];
                fastCounter = sourceArr[fastCounter - 1];
            }

            return fastCounter;
        }

        #endregion

        #region Find Max Product In a Array

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sourceArr"></param>
        /// <param name="digitCount"></param>
        /// <param name="maxProduct"></param>
        /// <returns></returns>
        public static int[] FindMaxProduct(int[] sourceArr, int digitCount, out long maxProduct)
        {
            //check input validity
            if (sourceArr == null || sourceArr.Length < 3 || digitCount < 2 || 2 * digitCount > sourceArr.Length)
            {
                throw new Exception("invalid input");
            }

            int[] maxArr = new int[digitCount];                                                 //largest numbers count is same 
            for (int counter = 0; counter < maxArr.Length; counter++)
            {
                maxArr[counter] = int.MinValue;
            }

            int[] minArr = new int[digitCount % 2 == 0 ? digitCount : digitCount - 1];          //smallest numbers count depends on even/odd
            for (int counter = 0; counter < minArr.Length; counter++)
            {
                minArr[counter] = int.MaxValue;
            }

            //we need to avoid '0' as anythng multiplied with 0 is 0
            int avoidNo = 0;

            //check the entire array and find k largest numbers
            //and either k or k-1 smallest numbers as min1 * min2 could be larger than max1 * max2
            //because (-4) * (-3) is > 2 * 5
            for (int index = 0; index < sourceArr.Length; index++)
            {
                if (avoidNo != sourceArr[index])
                {
                    maxArr = CheckMax(maxArr, sourceArr[index]);

                    minArr = CheckMin(minArr, sourceArr[index]);
                }
            }

            return GetMaxProductEither(maxArr, minArr, out maxProduct);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="maxArr"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        private static int[] CheckMin(int[] minArr, int value)
        {
            //error check
            if (null == minArr || minArr.Length == 0)
            {
                throw new Exception("invalid maxx numbers.");
            }
            else
            {
                //compare with each number and insert accordingly
                for (int index1 = 0; index1 < minArr.Length; index1++)
                {
                    if (value < minArr[index1])
                    {
                        for (int index2 = minArr.Length - 1; index2 > index1; index2--)
                        {
                            minArr[index2] = minArr[index2 - 1];
                        }

                        minArr[index1] = value;
                        break;
                    }
                }
            }

            return minArr;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="maxArr"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        private static int[] CheckMax(int[] maxArr, int value)
        {
            //error check
            if (null == maxArr || maxArr.Length == 0)
            {
                throw new Exception("invalid maxx numbers.");
            }
            else
            {
                //compare with each number and insert accordingly
                for (int index1 = 0; index1 < maxArr.Length; index1++)
                {
                    if (value > maxArr[index1])
                    {
                        for (int index2 = maxArr.Length - 1; index2 > index1; index2--)
                        {
                            maxArr[index2] = maxArr[index2 - 1];
                        }

                        maxArr[index1] = value;
                        break;
                    }
                }
            }

            return maxArr;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="maxArr"></param>
        /// <param name="minArr"></param>
        /// <param name="maxProduct"></param>
        /// <returns></returns>
        private static int[] GetMaxProductEither(int[] maxArr, int[] minArr, out long maxProduct)
        {
            //error check
            if (null == maxArr || null == minArr || maxArr.Length == 0 || minArr.Length == 0)
            {
                throw new Exception("invalid maxx or minn numbers.");
            }
            else
            {
                int[] returningArr = new int[maxArr.Length];
                int indexMax = 0, indexMin = 0, index = 0;
                maxProduct = 1;

                for (; index < returningArr.Length - 1 && indexMax < maxArr.Length - 1 && indexMin < minArr.Length - 1;)
                {
                    if (maxArr[indexMax] > Math.Abs(minArr[indexMin]))
                    {
                        maxProduct *= maxArr[indexMax];
                        returningArr[index] = maxArr[indexMax];
                        indexMax++;
                        index++;
                        continue;
                    }

                    if ((maxArr[indexMax] * maxArr[indexMax + 1]) < (minArr[indexMin] * minArr[indexMin + 1]))
                    {
                        maxProduct *= (minArr[indexMin] * minArr[indexMin + 1]);
                        returningArr[index] = minArr[indexMin];
                        returningArr[index + 1] = minArr[indexMin + 1];
                        indexMin += 2;
                        index += 2;
                    }
                    else
                    {
                        maxProduct *= (maxArr[indexMax] * maxArr[indexMax + 1]);
                        returningArr[index] = maxArr[indexMax];
                        returningArr[index + 1] = maxArr[indexMax + 1];
                        indexMax += 2;
                        index += 2;
                    }
                }

                if (index == returningArr.Length - 1)
                {
                    if (maxArr[maxArr.Length - 1] < Math.Abs(minArr[minArr.Length - 1]))
                    {
                        maxProduct *= minArr[minArr.Length - 1];
                        returningArr[returningArr.Length - 1] = minArr[minArr.Length - 1];
                    }
                    else
                    {
                        maxProduct *= maxArr[maxArr.Length - 1];
                        returningArr[returningArr.Length - 1] = maxArr[maxArr.Length - 1];
                    }
                }

                return returningArr;
            }
        }

        #endregion

        #region Find Kth Element (largest & smallest) in a BST

        /// <summary>
        /// Find K-th Largest node
        /// </summary>
        /// <param name="root"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static TreeNode FindKthLargestNode(TreeNode root, int value)
        {
            //Check for null
            if (root == null || (root.Left == null && root.Right == null))
            {
                throw new Exception("Invalid input node");
            }

            int counter = 0;
            return FindKthLargestNode(root, value, ref counter);
        }

        /// <summary>
        /// Helper method to find k-th largest node
        /// </summary>
        /// <param name="root"></param>
        /// <param name="value"></param>
        /// <param name="counter"></param>
        /// <returns></returns>
        private static TreeNode FindKthLargestNode(TreeNode root, int value, ref int counter)
        {
            //base case
            if (root == null || counter >= value)
            {
                return root;
            }
            else
            {
                var fromRight = FindKthLargestNode(root.Right, value, ref counter);

                counter++;
                if (fromRight != null && counter >= value)
                {
                    return fromRight;
                }
                else if (counter == value)
                {
                    return root;
                }

                return FindKthLargestNode(root.Left, value, ref counter);
            }
        }

        /// <summary>
        /// Find K-th Smallest node
        /// </summary>
        /// <param name="root"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static TreeNode FindKthSmallestNode(TreeNode root, int value)
        {
            //Check for null
            if (root == null || (root.Left == null && root.Right == null))
            {
                throw new Exception("Invalid input node");
            }

            int counter = 0;
            return FindKthSmallestNode(root, value, ref counter);
        }

        /// <summary>
        /// Helper method to find k-th Smallest node
        /// </summary>
        /// <param name="root"></param>
        /// <param name="value"></param>
        /// <param name="counter"></param>
        /// <returns></returns>
        private static TreeNode FindKthSmallestNode(TreeNode root, int value, ref int counter)
        {
            //base case
            if (root == null || counter >= value)
            {
                return root;
            }
            else
            {
                var fromLeft = FindKthSmallestNode(root.Left, value, ref counter);

                counter++;
                if (fromLeft != null && counter >= value)
                {
                    return fromLeft;
                }
                else if (counter == value)
                {
                    return root;
                }

                return FindKthSmallestNode(root.Right, value, ref counter);
            }
        }

        #endregion

        #region Cake Thief

        /// <summary>
        /// Cake class
        /// </summary>
        internal class Cake
        {
            public int Weight { get; set; }
            public int Price { get; set; }

            public Cake(int weight, int price)
            {
                this.Weight = weight;
                this.Price = price;
            }

            public double GetAvgPrice()
            {
                return (double)(Price / Weight);
            }
        }

        /// <summary>
        /// Merge cakes list to get the sorted array
        /// </summary>
        /// <param name="cakes"></param>
        /// <param name="left"></param>
        /// <param name="mid"></param>
        /// <param name="right"></param>
        private static void DoMergeCakes(Cake[] cakes, int left, int mid, int right)
        {
            int i, left_end, num_elements, tmp_pos;

            left_end = (mid - 1);
            tmp_pos = left;
            num_elements = (right - left + 1);
            Cake[] temp = new Cake[cakes.Length];

            while ((left <= left_end) && (mid <= right))
            {
                if (cakes[left].GetAvgPrice() <= cakes[mid].GetAvgPrice())
                    temp[tmp_pos++] = cakes[left++];
                else
                    temp[tmp_pos++] = cakes[mid++];
            }

            while (left <= left_end)
                temp[tmp_pos++] = cakes[left++];

            while (mid <= right)
                temp[tmp_pos++] = cakes[mid++];

            for (i = 0; i < num_elements; i++)
            {
                cakes[right] = temp[right];
                right--;
            }
        }

        /// <summary>
        /// Sorting Cakes array based on their avg price
        /// </summary>
        /// <param name="cakes"></param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        public static void MergeSortCake(Cake[] cakes, int left, int right)
        {
            int mid;

            if (right > left)
            {
                mid = (right + left) / 2;
                MergeSortCake(cakes, left, mid);
                MergeSortCake(cakes, (mid + 1), right);

                DoMergeCakes(cakes, left, (mid + 1), right);
            }
        }

        /// <summary>
        /// Find maximum utilization of duffle bag
        /// Utilization: O(nlgn) time and O(n) space
        /// </summary>
        /// <param name="cakes"></param>
        /// <param name="totalWeight"></param>
        /// <returns></returns>
        private static int MaxUtilizeDuffle(Cake[] cakes, int totalWeight)
        {
            MergeSortCake(cakes, 0, cakes.Length - 1);

            int maxUtil = 0, target = totalWeight;
            for (int index = cakes.Length - 1; index >= 0; index--)
            {
                if (target <= 0)
                {
                    break;
                }

                if (cakes[index].Weight == 0 || cakes[index].Price == 0)
                {
                    continue;
                }

                if (cakes[index].Weight <= target)
                {
                    int kilos = (int)(target / cakes[index].Weight);
                    target -= (kilos * cakes[index].Weight);
                    maxUtil += (kilos * cakes[index].Price);
                }
            }

            return maxUtil;
        }

        /// <summary>
        /// Find maximum utilization of duffle bag
        /// Utilization: O(n*m) time and O(m) space
        /// </summary>
        /// <param name="cakes"></param>
        /// <param name="weightCapacity"></param>
        /// <returns></returns>
        private static long MaxDuffelBagValue(Cake[] cakes, int weightCapacity)
        {

            // we make an array to hold the maximum possible value at every
            // duffel bag weight capacity from 0 to weightCapacity
            // starting each index with value 0
            long[] maxValuesAtCapacities = new long[weightCapacity + 1];

            for (int currentCapacity = 0; currentCapacity <= weightCapacity; currentCapacity++)
            {

                // set a variable to hold the max monetary value so far for currentCapacity
                long currentMaxValue = 0;

                foreach (Cake cake in cakes)
                {

                    // if a cake weighs 0 and has a positive value the value of our duffel bag is infinite!
                    if (cake.Weight == 0 && cake.Price != 0)
                    {
                        throw new Exception("Cake weight is zero and price is non-zero, encountered infinity");
                    }

                    // if the current cake weighs as much or less than the current weight capacity
                    // it's possible taking the cake would give get a better value
                    if (cake.Weight <= currentCapacity)
                    {

                        // so we check: should we use the cake or not?
                        // if we use the cake, the most kilograms we can include in addition to the cake
                        // we're adding is the current capacity minus the cake's weight. we find the max
                        // value at that integer capacity in our array maxValuesAtCapacities
                        long maxValueUsingCake = cake.Price + maxValuesAtCapacities[currentCapacity - cake.Weight];

                        // now we see if it's worth taking the cake. how does the
                        // value with the cake compare to the currentMaxValue?
                        currentMaxValue = Math.Max(maxValueUsingCake, currentMaxValue);
                    }
                }

                // add each capacity's max value to our array so we can use them
                // when calculating all the remaining capacities
                maxValuesAtCapacities[currentCapacity] = currentMaxValue;
            }

            return maxValuesAtCapacities[weightCapacity];
        }

        #endregion

        #region Find Coin Combinations

        /// <summary>
        /// Method to find the combinations of getting a sum using provided coins denominations
        /// </summary>
        /// <param name="sum"></param>
        /// <param name="values"></param>
        /// <returns></returns>
        public static int FindCombinationsCount(int sum, List<int> values)
        {
            //Validity check
            if (sum < 0)
            {
                return 0;
            }
            else if (values == null || values.Count == 0)
            {
                return 0;
            }

            int[] combinations = new int[sum + 1];
            combinations[0] = 1;
            for (int index = 0; index < values.Count; ++index)
            {
                for (int index2 = values[index]; index2 <= sum; ++index2)
                {
                    combinations[index2] += combinations[index2 - values[index]];
                }
            }
            return combinations[sum];
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sum"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static int CountCombinations(int sum, int value)
        {
            //Error check
            if (value <= 0 || sum < 0 || value > sum)
            {
                return 0;
            }
            //base case
            else if (sum == 0 || sum == value)
            {
                return 1;
            }
            else
            {
                for (int index = 0; index <= sum; ++index)
                {
                    var tempKey = string.Format("{0}-{1}", sum, value);
                    //var tempKey2 = string.Format("{0}-{1}", (sum - index), index);

                    //Check if already computed
                    if (!knownCount.ContainsKey(tempKey))
                    {
                        var tempCount = CountCombinations(sum - index, index);
                        knownCount[tempKey] = tempCount;
                    }
                }

                return knownCount[string.Format("{0}-{1}", sum, value)];
            }
        }

        #endregion

        #region Look and Say Series

        public static List<string> GetLookNSaySeries(string firstTerm, int termCount)
        {
            List<string> series = new List<string>();
            LookNSayNumber start = new LookNSayNumber(firstTerm);
            series.Add(firstTerm);

            for (int index = 1; index < termCount; index++)
            {
                var temp = start.GetNextNumber();
                series.Add(temp);
                start = new LookNSayNumber(temp);
            }

            Console.WriteLine(start.GetPrevNumber());
            Console.WriteLine(start.GetCurrentNumber());
            Console.WriteLine(start.GetNextNumber());

            return series;
        }



        #endregion
    }

    #region Google

    public class Google
    {


        /* Divide S in K parts 0 may be present */
        public static long PartionwithZero(int sum, int value)
        {
            long[][] DP_Table = new long[value][];


            for (int i = 0; i < value; i++)
                DP_Table[i] = new long[sum + 1];
            for (int i = 0; i < sum + 1; i++)
                DP_Table[0][i] = 1;
            for (int i = 0; i < value; i++)
                DP_Table[i][0] = 1;

            for (int i = 1; i < value; i++)
            {
                for (int j = 1; j < sum + 1; j++)
                    DP_Table[i][j] = DP_Table[i - 1][j] + DP_Table[i][j - 1];
            }

            return DP_Table[value - 1][sum];
        }


        /* Divide S in K parts 0 should not be present *//*
        public static long PartionwithoutZero(int S, int K)
{
    long[][] DP_Table = new long[K][];
    for (int i = 0; i<S; i++)
        DP_Table[0][i] = 1;
    for (int i = 1; i<K; i++)
        DP_Table[i][0] = 0;

    for (int i = 1; i<K; i++) {
        for (int j = 1; j<S; j++)
            DP_Table[i][j] = DP_Table[i - 1][j - 1] + DP_Table[i][j - 1];
    }

    /*
     * for(long i=0;i<K;i++) { for(long j=0;j<S;j++)
     * System.out.print(DP_Table[i][j]+" "); System.out.println(); }
     *//*
    return DP_Table[K - 1][S - 1];
}

        /*
/* Divide S in K parts 0 may be present *//*
public static long PartionwithZeroUnique(int S, int K)
{
    long DP_Table[][]
[] = new long[K][S + 1][S + 1]; // DP_Table[no of
                                                        // partition][Sum][Maximum
                                                        // value in the
                                                        // partition]

    for (int i = 0; i<K; i++)
        DP_Table[i][0][0] = 1;
    for (int i = 1; i<S + 1; i++) {
        DP_Table[0][i][0] = 0;
        DP_Table[0][i][i] = 1;
    }
    for (int i = 1; i<S + 1; i++)
        DP_Table[0][0][i] = 0;

    for (int i = 0; i<S + 1; i++)
        for (int j = 0; j<i; j++)
            DP_Table[0][i][j] = 1;

    for (int i = 1; i<K; i++) {
        for (int j = 1; j<S + 1; j++)
            for (int k = 1; k<S + 1; k++) {
                // System.out.println(i+" "+j+" "+k);
                DP_Table[i][j][k] = (k - j) >= 0 ? DP_Table[i - 1][j]
[k - j]
                        : 0;
            }
        for (int k = 0; k<S + 1; k++) {
            long sum = 0;
            for (int j = 0; j<S + 1; j++) {
                DP_Table[i][j][k] += sum;
                sum = DP_Table[i][j][k];
            }
        }
    }

    /*
     * for(int i=0;i<K;i++) { System.out.println("K ="+i); for(int
     * j=0;j<S+1;j++) { for(int k=0;k<S+1;k++)
     * System.out.print(DP_Table[i][j][k]+" "); System.out.println(); }
     * System.out.println(); System.out.println(); }
     *//*
    return DP_Table[K - 1][S][S];
}*/

    }


    #endregion

    #region LinkedList Classes

    #region LinedListNode class
    public unsafe class LinkedListNode
    {
        public LinkedListNode Next { get; set; }
        public LinkedListNode Prev { get; set; }
        public LinkedListNode Last { get; set; }
        public int Data { get; set; }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="d">Data</param>
        /// <param name="n">Next</param>
        /// <param name="p">Previous</param>
        public LinkedListNode(int d, LinkedListNode n, LinkedListNode p)
        {
            Data = d;
            SetNext(n);
            SetPrevious(p);
        }

        public LinkedListNode()
        { }

        public void SetNext(LinkedListNode n)
        {
            Next = n;
            if (this == Last)
            {
                Last = n;
            }
            if (n != null && n.Prev != this)
            {
                n.SetPrevious(this);
            }
        }

        public void SetPrevious(LinkedListNode p)
        {
            Prev = p;
            if (p != null && p.Next != this)
            {
                p.SetNext(this);
            }
        }

        public string PrintForward()
        {
            if (Next != null)
            {
                return string.Format("{0}.{1}", Data, Next.PrintForward());
            }
            else
            {
                return string.Format("{0}", Data);
            }
        }

        public LinkedListNode Clone()
        {
            LinkedListNode next2 = null;
            if (Next != null)
            {
                next2 = Next.Clone();
            }
            LinkedListNode head2 = new LinkedListNode(Data, next2, null);
            return head2;
        }
    }
    #endregion

    /// <summary>
    /// Class to use for arithmatic operation on linked list
    /// </summary>
    public class Solution27
    {
        public LinkedListNode value = null;
        public bool result = false;

        public Solution27(LinkedListNode Value, bool Result)
        {
            this.result = Result;
            this.value = Value;
        }
    }

    #endregion

    #region Stack Classes

    /// <summary>
    /// Class to implement my own stack
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class MyStack<T>
    {
        private T[] stack;
        private int currentStackIndex;
        public int TopOfStack
        {
            get
            {
                return currentStackIndex - 1;
            }
        }
        public int Count
        {
            get
            {
                return currentStackIndex + 1;
            }
        }

        public MyStack(int size)
        {
            if (size < 0)
                throw new ArgumentOutOfRangeException("Size");

            stack = new T[size];
            currentStackIndex = 0;
        }

        public void Push(T value)
        {
            if (currentStackIndex + 1 >= stack.Length)
            {
                //Notice the + 1, to counter the 0 Length problem
                Array.Resize(ref stack, (stack.Length + 1) * 2);
            }

            stack[currentStackIndex++] = value;
        }

        public T Pop()
        {
            if (currentStackIndex == 0)
                throw new InvalidOperationException("The stack is empty");

            T value = stack[--currentStackIndex];
            stack[currentStackIndex] = default(T);
            return value;
        }

        public T Peek()
        {
            if (currentStackIndex == 0)
                throw new InvalidOperationException("The stack is empty");

            return stack[currentStackIndex];
        }

        public void Clear()
        {
            stack = new T[0];
            currentStackIndex = 0;
        }

    }

    /// <summary>
    /// Class to store dynamic stack's info
    /// </summary>
    public class StackData
    {
        public int size, capacity, pointer, start;

        public StackData(int Start, int Capacity)
        {
            this.start = Start;
            this.size = 0;
            this.capacity = Capacity;
            this.pointer = start - 1;
        }

        public bool IsWithinStack(int index, int totalSize)
        {
            if (index > start && index < (start + capacity))
            {
                return true;
            }
            else if ((start + capacity) > totalSize && index < ((start + capacity) % totalSize))
            {
                return true;
            }
            else
                return false;
        }

    }

    #endregion

    #region Tree Classes

    /// <summary>
    /// Tree-Node
    /// </summary>
    public class TreeNode
    {
        #region Members
        private int data, size;
        private TreeNode left, right, parent;
        #endregion

        #region Properties
        public int Data
        {
            get
            {
                return data;
            }
            set
            {
                data = value;
            }
        }
        public TreeNode Left
        {
            get
            {
                return left;
            }
            set
            {
                left = value;
            }
        }
        public TreeNode Right
        {
            get
            {
                return right;
            }
            set
            {
                right = value;
            }
        }
        public TreeNode Parent
        {
            get
            {
                return parent;
            }
            set
            {
                parent = value;
            }
        }
        public int Size
        {
            get
            {
                return size;
            }
            set
            {
                size = value;
            }
        }
        #endregion

        /// <summary>
        /// Method to get the number of nodes under this node
        /// including current one, this doesn't count the nodes on top of it.
        /// </summary>
        /// <returns>Node count, integer</returns>
        public int GetTreeSize()
        {
            int leftNodeCount = 0, rightNodeCount = 0;

            if (Left != null)
            {
                leftNodeCount = Left.GetTreeSize();
            }

            if (Right != null)
            {
                rightNodeCount = Right.GetTreeSize();
            }

            Size = leftNodeCount + rightNodeCount + 1;
            return Size;

        }

        public TreeNode(int data)
        {
            Data = data;
            Size = 1;
        }

        public void SetLeftChild(TreeNode left)
        {
            Left = left;

            if (left != null)
            {
                left.Parent = this;
            }
        }

        public void SetRightChild(TreeNode right)
        {
            Right = right;

            if (right != null)
            {
                right.Parent = this;
            }
        }

        public void InsertInOrder(int data)
        {
            if (data <= Data)
            {
                if (Left == null)
                {
                    SetLeftChild(new TreeNode(data));
                }
                else
                {
                    Left.InsertInOrder(data);
                }
            }
            else
            {
                if (Right == null)
                {
                    SetRightChild(new TreeNode(data));
                }
                else
                {
                    Right.InsertInOrder(data);
                }
            }

            Size++;
        }

        public bool IsBst()
        {
            //following doesn't handle few key scenarios
            if (Left != null)
            {
                if (Data < Left.Data || !Left.IsBst())
                {
                    return false;
                }
            }

            if (Right != null)
            {
                if (Data >= Right.Data || !Right.IsBst())
                {
                    return false;
                }
            }

            return true;


            //BSTCheckerRecursive(this);
        }

        public int Height()
        {
            var leftHeight = Left != null ? Left.Height() : 0;
            var rightHeight = Right != null ? Right.Height() : 0;

            return 1 + Math.Max(leftHeight, rightHeight);
        }

        public TreeNode Find(int data)
        {
            if (data == Data)
            {
                return this;
            }
            else if (data <= Data)
            {
                return Left != null ? Left.Find(data) : null;
            }
            else if (data > Data)
            {
                return Right != null ? Right.Find(data) : null;
            }

            return null;
        }

        private static TreeNode CreateMinimalBst(int[] array, int start, int end)
        {
            if (end < start)
            {
                return null;
            }

            var mid = (start + end) / 2;
            var treeNode = new TreeNode(array[mid]);
            treeNode.SetLeftChild(CreateMinimalBst(array, start, mid - 1));
            treeNode.SetRightChild(CreateMinimalBst(array, mid + 1, end));

            return treeNode;
        }

        /// <summary>
        /// Create minimal BST from an array
        /// </summary>
        /// <param name="array"></param>
        /// <returns></returns>
        public static TreeNode CreateMinimalBst(int[] array)
        {
            return CreateMinimalBst(array, 0, array.Length - 1);
        }

        /// <summary>
        /// Create custom tree from In-Order string
        /// </summary>
        /// <param name="custInOrder"></param>
        /// <returns></returns>
        public static TreeNode CreateTreeFromInOrder(string custInOrder)
        {
            if (string.IsNullOrEmpty(custInOrder))
            {
                return null;
            }
            else
            {
                TreeNode root = null;
                var datas = custInOrder.Split(',');

                int tempInt = int.MinValue;
                if (int.TryParse(datas[0].Trim(), out tempInt))
                {
                    root = new TreeNode(tempInt);
                }
                else
                    throw new Exception("Invalid data element");

                for (int index = 1; index < datas.Length; index++)
                {
                    if (int.TryParse(datas[index].Trim(), out tempInt))
                    {
                        root.InsertInOrder(tempInt);
                    }
                    else
                        throw new Exception("Invalid data element");
                }

                return root;
            }
        }
    }

    /// <summary>
    /// AA tree
    /// </summary>
    public class AATree
    {
        public int Data { get; set; }
        public int Level { get; set; }

        public AATree LeftChild { get; set; }
        public AATree RightChild { get; set; }

        private static int size = 0;
        private static AATree lastNode, deleteNode;


        //Constructors
        public AATree(int data, int level)
        {
            this.Data = data;
            this.Level = level;
            size++;
        }

        public AATree(int data, int level, AATree left, AATree right)
        {
            this.Data = data;
            this.Level = level;
            this.LeftChild = left;
            this.RightChild = right;
            size++;
        }

        #region Static Methods

        /// <summary>
        /// Skew Method
        /// </summary>
        /// <param name="root"></param>
        /// <returns></returns>
        public static AATree Skew(AATree root)
        {
            if (root == null || root.LeftChild == null)
            {
                return root;
            }
            else if (root.LeftChild.Level == root.Level)
            {
                //Swap pointers of horizontal links
                var temp = root.LeftChild;
                root.LeftChild = temp.RightChild;
                temp.RightChild = root;
                return temp;
            }
            else
                return root;
        }

        /// <summary>
        /// Split Method
        /// </summary>
        /// <param name="root"></param>
        /// <returns></returns>
        public static AATree Split(AATree root)
        {
            if (root == null || root.RightChild == null || root.RightChild.RightChild == null)
            {
                return root;
            }
            else if (root.Level == root.RightChild.RightChild.Level)
            {
                //pull up middle node and increment it's level
                var temp = root.RightChild;
                root.RightChild = temp.LeftChild;
                temp.LeftChild = root;
                temp.Level++;
                return temp;
            }
            else
                return root;
        }

        #endregion

        #region Other Operations

        /// <summary>
        /// Inserting a new node in the AA tree
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public AATree Insert(int data)
        {
            return Insert(data, this);
        }

        /// <summary>
        /// Inserting a new node
        /// </summary>
        /// <param name="data"></param>
        /// <param name="root"></param>
        /// <returns></returns>
        private AATree Insert(int data, AATree root)
        {
            //Normal BST insertion and then balance after that
            if (this == null || size == 0)
            {
                return Split(Skew(new AATree(data, 1, null, null)));
            }
            else if (data < this.Data)
            {
                return Split(Skew(Insert(data, root.LeftChild)));
            }
            else if (data > this.Data)
            {
                return Split(Skew(Insert(data, root.RightChild)));
            }
            else
                throw new Exception("Duplicate Item cannot be inserted.");
        }

        /// <summary>
        /// Removes a specified node containing the data element from the AA tree
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public AATree Delete(int data)
        {
            return Delete(data, this);
        }

        /// <summary>
        /// Removes a data element from a given AA tree
        /// </summary>
        /// <param name="data"></param>
        /// <param name="root"></param>
        /// <returns></returns>
        private AATree Delete(int data, AATree root)
        {
            AATree returningTree = null;

            if (root == null || size == 0)
            {
                return root;
            }

            //Traverse and find lastNode and deleteNode
            lastNode = root;
            if (data < root.Data)
            {
                returningTree = Delete(data, root.LeftChild);
            }
            else if (data > root.Data)
            {
                deleteNode = root;
                returningTree = Delete(data, root.RightChild);
            }
            else
            {
                //If already at the bottom node, just delete the node
                if (root == lastNode)
                {
                    if (deleteNode == null || deleteNode.Data != data)
                    {
                        throw new Exception("Item not found.");
                    }

                    deleteNode.Data = root.Data;
                    deleteNode = null;
                    root = root.RightChild;

                    returningTree = root;
                }
                //if not at bottom node, rebalance
                else if (root.LeftChild.Level < root.Level - 1 || root.RightChild.Level < root.Level - 1)
                {
                    if (root.RightChild.Level > --root.Level)
                    {
                        root.RightChild.Level = root.Level;
                    }

                    returningTree = Split(Split(Skew(Skew(Skew(root).RightChild).RightChild)).RightChild);
                }
            }

            return returningTree;
        }

        #endregion
    }

    /// <summary>
    /// AVL Tree, autobalancing tree class
    /// </summary>
    public class AVLTree
    {
        class Node
        {
            public int data;
            public Node left;
            public Node right;
            public Node(int data)
            {
                this.data = data;
            }
        }
        Node root;
        public AVLTree(int data)
        {
            Add(data);
        }
        public void Add(int data)
        {
            Node newItem = new Node(data);
            if (root == null)
            {
                root = newItem;
            }
            else
            {
                root = RecursiveInsert(root, newItem);//root = null so we dont lose track of the root and we assign a new root if necessary
            }
        }
        private Node RecursiveInsert(Node current, Node n)
        {
            if (current == null)//base case, we reach this when we go left or right until current is null
            {
                current = n;
                return current;
            }
            else if (n.data < current.data)//if the new node is less than the current node
            {
                current.left = RecursiveInsert(current.left, n);//go left
                current = balance_tree(current);//calling balance after recursion
            }
            else if (n.data > current.data)//if the new node is greater than the current node
            {
                current.right = RecursiveInsert(current.right, n);
                current = balance_tree(current);
            }
            return current;
        }
        private Node balance_tree(Node current)
        {
            int b_factor = balance_factor(current);
            if (b_factor > 1)
            {
                if (balance_factor(current.left) > 0)
                {
                    current = RotateLL(current);
                }
                else
                {
                    current = RotateLR(current);
                }
            }
            else if (b_factor < -1)
            {
                if (balance_factor(current.right) > 0)
                {
                    current = RotateRL(current);
                }
                else
                {
                    current = RotateRR(current);
                }
            }
            return current;
        }
        public void Delete(int target)
        {
            Delete(root, target);
        }
        public void Find(int key)
        {
            if (Find(key, root).data == key)
            {
                Console.WriteLine("{0} was found!", key);
            }
            else
            {
                Console.WriteLine("Nothing found!");
            }
        }
        private Node Find(int target, Node current)
        {

            if (target < current.data)
            {
                if (target == current.data)
                {
                    return current;
                }
                else
                    return Find(target, current.left);
            }
            else
            {
                if (target == current.data)
                {
                    return current;
                }
                else
                    return Find(target, current.right);
            }

        }
        public void DisplayTree()
        {
            InOrderDisplayTree(root);
            Console.ReadLine();
        }
        private void InOrderDisplayTree(Node current)
        {
            if (current != null)
            {
                InOrderDisplayTree(current.left);
                Console.Write("({0}) ", current.data);
                InOrderDisplayTree(current.right);
            }
        }
        private int max(int l, int r)//returns maximum of two integers
        {
            return l > r ? l : r;
        }
        private int getHeight(Node current)
        {
            int height = 0;
            if (current != null)
            {
                int l = getHeight(current.left);
                int r = getHeight(current.right);
                int m = max(l, r);
                height = m + 1;
            }
            return height;
        }
        private int balance_factor(Node current)
        {
            int l = getHeight(current.left);
            int r = getHeight(current.right);
            int b_factor = l - r;
            return b_factor;
        }
        private Node RotateRR(Node parent)
        {
            Node pivot = parent.right;
            parent.right = pivot.left;
            pivot.left = parent;
            return pivot;
        }
        private Node RotateLL(Node parent)
        {
            Node pivot = parent.left;
            parent.left = pivot.right;
            pivot.right = parent;
            return pivot;
        }
        private Node RotateLR(Node parent)
        {
            Node pivot = parent.left;
            parent.left = RotateRR(pivot);
            return RotateLL(parent);
        }
        private Node RotateRL(Node parent)
        {
            Node pivot = parent.right;
            parent.right = RotateLL(pivot);
            return RotateRR(parent);
        }
        private Node Delete(Node current, int target)
        {
            Node parent;
            if (current == null)
            { return null; }
            else
            {
                //left subtree
                if (target < current.data)
                {
                    current.left = Delete(current.left, target);
                    if (balance_factor(current) == -2)
                    {
                        if (balance_factor(current.left) <= 0)
                        {
                            current = RotateRR(current);
                        }
                        else
                        {
                            current = RotateRL(current);
                        }
                    }
                }
                //right subtree
                else if (target > current.data)
                {
                    current.right = Delete(current.right, target);
                    if (balance_factor(current) == 2)
                    {
                        if (balance_factor(current.right) <= 0)
                        {
                            current = RotateLL(current);
                        }
                        else
                        {
                            current = RotateLR(current);
                        }
                    }
                }
                //if target is found
                else
                {
                    if (current.right != null)
                    {
                        //delete its inorder successor
                        parent = current.right;
                        while (parent.left != null)
                        {
                            parent = parent.left;
                        }
                        current.data = parent.data;
                        current.right = Delete(current.right, parent.data);
                        if (balance_factor(current) == 2)//rebalancing
                        {
                            if (balance_factor(current.left) <= 0)
                            {
                                current = RotateLL(current);
                            }
                            else { current = RotateLR(current); }
                        }
                    }
                    else
                    {
                        return current.left;
                    }
                }
            }
            return current;
        }
    }

    /// <summary>
    /// Binary Tree using arraylist
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class BinaryTree<T>
    {
        ArrayList dataArray;
        int lastRemovedItemIndex = -1;

        public BinaryTree()
        {
            dataArray = new ArrayList();
        }

        //function to insert data in to the tree
        //insert as a complete binary tree
        public void InsertData(T data)
        {
            if (lastRemovedItemIndex == -1)
            {
                dataArray.Add(data);
            }
            else
            {
                dataArray[lastRemovedItemIndex] = data;
                lastRemovedItemIndex = -1;
            }
        }

        //internal function used to get the left child of an element in the array
        int GetLeftChildIndex(int index)
        {
            if (dataArray.Count > (2 * index + 1))
                return (2 * index + 1);
            return -1;
        }

        //internal function used to get the right child of an element in the array
        int GetRightChildIndex(int index)
        {
            if (dataArray.Count > (2 * index + 2))
                return (2 * index + 2);
            return -1;
        }
        //function to check if the tree is empty
        public bool IsTreeEmpty()
        {
            if (dataArray.Count < 1)
                return true;
            return false;
        }

        //fetch index of an item
        int GetIndex(T item)
        {
            if (null != item)
            {
                for (int index = 0; index < dataArray.Count; index++)
                {
                    if (dataArray[index].Equals(item))
                    {
                        return index;
                    }
                }
            }

            return -1;
        }

        /// <summary>
        /// Get Left child
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public T LeftChild(T item)
        {
            int index = GetIndex(item);
            int leftChildIndex = GetLeftChildIndex(index);

            if (index != -1 && leftChildIndex != -1)
            {
                return (T)dataArray[leftChildIndex];
            }
            else
                return default(T);
        }

        /// <summary>
        /// Get Right child
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public T RightChild(T item)
        {
            int index = GetIndex(item);
            int rightChildIndex = GetRightChildIndex(index);

            if (index != -1 && rightChildIndex != -1)
            {
                return (T)dataArray[rightChildIndex];
            }
            else
                return default(T);
        }

        /// <summary>
        /// Delete an existing node
        /// </summary>
        /// <param name="item"></param>
        public bool DeleteNode(T item)
        {
            int index = GetIndex(item);
            if (index != -1)
            {
                DeleteNodeFromIndex(index);
                return true;
            }
            else
                return false;
        }

        //Recusrive remove, softly
        private void DeleteNodeFromIndex(int index)
        {
            //find replacement index
            int replacementIndex = GetLeftChildIndex(index);
            if (replacementIndex == -1)
            {
                replacementIndex = GetRightChildIndex(index);
            }

            //replace recusively
            if (replacementIndex != -1)
            {
                dataArray[index] = dataArray[replacementIndex];
                DeleteNodeFromIndex(replacementIndex);
            }
            //if no child, soft-remove
            else
            {
                dataArray[index] = "Item deleted";
                lastRemovedItemIndex = index;
            }
        }

        //recursive function for inorder traversal
        public void TraverseInOrder(int index)
        {
            if (index == -1)
                return;
            TraverseInOrder(GetLeftChildIndex(index));
            Console.Write("{0} ", dataArray[index]);
            TraverseInOrder(GetRightChildIndex(index));
        }

        //recursive function for preorder traversal
        public void TraversePreOrder(int index)
        {
            if (index == -1)
                return;
            Console.Write("{0} ", dataArray[index]);
            TraversePreOrder(GetLeftChildIndex(index));
            TraversePreOrder(GetRightChildIndex(index));
        }

        //recursive function for postorder traversal
        public void TraversePostOrder(int index)
        {
            if (index == -1)
                return;
            TraversePostOrder(GetLeftChildIndex(index));
            TraversePostOrder(GetRightChildIndex(index));
            Console.Write("{0} ", dataArray[index]);
        }

        //function to traverse the tree in level order
        public void TraverseLevelOrder()
        {
            Console.WriteLine("\nPrinting Elements Of The Tree In Ascending Level Order\n");
            if (dataArray.Count < 1)
            {
                Console.WriteLine("Empty Tree!...press any key to return");
                Console.ReadKey();
                return;
            }
            for (int i = 0; i < dataArray.Count; i++)
            {
                Console.Write("{0} ", dataArray[i]);
            }
            Console.WriteLine("\n");
        }
        
    }

    #endregion

    #region Misclenious

    public class Graph4BF
    {
        // A class to represent a weighted edge in graph
        public class Edge
        {
            public int src, dest, weight;
            public Edge()
            {
                src = dest = weight = 0;
            }
        };

        public int V, E;
        public Edge[] edge;

        // Creates a graph with V vertices and E edges
        public Graph4BF(int v, int e)
        {
            V = v;
            E = e;
            edge = new Edge[e];
            for (int i = 0; i < e; ++i)
                edge[i] = new Edge();
        }

        // The main function that finds shortest distances from src
        // to all other vertices using Bellman-Ford algorithm.  The
        // function also detects negative weight cycle
        public void BellmanFord(Graph4BF graph, int src)
        {
            int V = graph.V, E = graph.E;
            int[] dist = new int[V];

            // Step 1: Initialize distances from src to all other
            // vertices as INFINITE
            for (int i = 0; i < V; ++i)
                dist[i] = int.MaxValue;
            dist[src] = 0;

            // Step 2: Relax all edges |V| - 1 times. A simple
            // shortest path from src to any other vertex can
            // have at-most |V| - 1 edges
            for (int i = 1; i < V; ++i)
            {
                for (int j = 0; j < E; ++j)
                {
                    int u = graph.edge[j].src;
                    int v = graph.edge[j].dest;
                    int weight = graph.edge[j].weight;
                    if (dist[u] != int.MaxValue &&
                        dist[u] + weight < dist[v])
                        dist[v] = dist[u] + weight;
                }
            }

            // Step 3: check for negative-weight cycles.  The above
            // step guarantees shortest distances if graph doesn't
            // contain negative weight cycle. If we get a shorter
            //  path, then there is a cycle.
            for (int j = 0; j < E; ++j)
            {
                int u = graph.edge[j].src;
                int v = graph.edge[j].dest;
                int weight = graph.edge[j].weight;
                if (dist[u] != int.MaxValue &&
                    dist[u] + weight < dist[v])
                    Console.WriteLine("Graph contains negative weight cycle");
            }
            printArr(dist, V);
        }

        // A utility function used to print the solution
        internal void printArr(int[] dist, int V)
        {
            Console.WriteLine("Vertex   Distance from Source");
            for (int i = 0; i < V; ++i)
                Console.WriteLine("{0}\t\t{1}", i, dist[i]);
        }
    }

    /// <summary>
    /// Class to work with look and say number series
    /// </summary>
    public class LookNSayNumber
    {
        /*
        using a list of key-value pair where key is the number (range: 0 to 9)
        and value as it's consequtive frequency, helps in storing the number from
        a string object and generating the next one.
        */
        private List<KeyValuePair<char, int>> number = new List<KeyValuePair<char, int>>();

        public List<KeyValuePair<char, int>> Number
        {
            get { return number; }
            set { number = value; }
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="number"></param>
        public LookNSayNumber(string number)
        {
            var numberChars = number.ToCharArray();
            char lastValue = 'a';
            int lastCharsFreq = -1;

            for (int index = 0; index < numberChars.Length; index++)
            {
                if (lastValue.Equals('a') && lastCharsFreq == -1)
                {
                    lastValue = numberChars[index];
                    lastCharsFreq = 1;
                }
                else
                {
                    if (numberChars[index].Equals(lastValue))
                    {
                        lastCharsFreq++;
                    }
                    else
                    {
                        Number.Add(new KeyValuePair<char, int>(lastValue, lastCharsFreq));
                        lastValue = numberChars[index];
                        lastCharsFreq = 1;
                    }
                }
            }

            Number.Add(new KeyValuePair<char, int>(lastValue, lastCharsFreq));
        }

        /// <summary>
        /// Method to get the next number in a series
        /// </summary>
        /// <returns></returns>
        public string GetNextNumber()
        {
            StringBuilder nextNumber = new StringBuilder();

            for (int index = 0; index < Number.Count; index++)
            {
                nextNumber.Append(string.Format("{1}{0}", Number[index].Key, Number[index].Value));
            }

            return nextNumber.ToString();
        }

        /// <summary>
        /// Method to get the previous number in a series
        /// </summary>
        /// <returns></returns>
        public string GetPrevNumber()
        {
            StringBuilder prevNumber = new StringBuilder();

            for (int index = 0; index < Number.Count; index++)
            {
                prevNumber.Append(Number[index].Key, Number[index].Value);
            }

            return prevNumber.ToString();
        }

        /// <summary>
        /// Method to get the current number in a series
        /// </summary>
        /// <returns></returns>
        public string GetCurrentNumber()
        {
            StringBuilder currNumber = new StringBuilder();

            for (int index = 0; index < Number.Count; index++)
            {
                currNumber.Append(Number[index].Key);
            }

            return currNumber.ToString();
        }
    }

    #endregion

    #region Hash-Tables

    /* Class LinkedHashEntry */
    public class HashEntry
    {
        public string key;
        public int value;

        /* Constructor */
        public HashEntry(string key, int value)
        {
            this.key = key;
            this.value = value;
        }
    }

    /* Class HashTable */
    public class HashTable
    {
        private int TABLE_SIZE;
        private int size;
        private HashEntry[] table;
        private int primeSize;

        /* Constructor */
        public HashTable(int tableSize)
        {
            size = 0;
            TABLE_SIZE = tableSize;
            table = new HashEntry[TABLE_SIZE];
            for (int index = 0; index < TABLE_SIZE; index++)
                table[index] = null;
            primeSize = GetPrime();
        }

        /* Function to get prime number less than table size for myhash2 function */
        public int GetPrime()
        {
            for (int index = TABLE_SIZE - 1; index >= 1; index--)
            {
                int fact = 0;
                for (int index2 = 2; index2 <= (int)Math.Sqrt(index); index2++)
                    if (index % index2 == 0)
                    {
                        fact++;
                        break;
                    }

                if (fact == 0)
                    return index;
            }
            /* Return a prime number */
            return 3;
        }

        /* Function to get number of key-value pairs */
        public int GetSize()
        {
            return size;
        }

        public bool IsEmpty()
        {
            return size == 0;
        }

        /* Function to clear hash table */
        public void MakeEmpty()
        {
            size = 0;
            for (int index = 0; index < TABLE_SIZE; index++)
                table[index] = null;
        }

        /* Function to get value of a key */
        public int Get(string key)
        {
            int hash1 = Myhash1(key);
            int hash2 = Myhash2(key);

            while (table[hash1] != null && !table[hash1].key.Equals(key))
            {
                hash1 += hash2;
                hash1 %= TABLE_SIZE;
            }

            if (table[hash1] == null)
            {
                throw new Exception("Item not found.");
            }

            return table[hash1].value;
        }

        /* Function to insert a key value pair */
        public void Insert(string key, int value)
        {
            if (size == TABLE_SIZE)
            {
                Console.WriteLine("Table full");
                return;
            }
            int hash1 = Myhash1(key);
            int hash2 = Myhash2(key);
            while (table[hash1] != null)
            {
                hash1 += hash2;
                hash1 %= TABLE_SIZE;
            }
            table[hash1] = new HashEntry(key, value);
            size++;
        }

        /* Function to remove a key */
        public void Remove(string key)
        {
            int hash1 = Myhash1(key);
            int hash2 = Myhash2(key);
            while (table[hash1] != null && !table[hash1].key.Equals(key))
            {
                hash1 += hash2;
                hash1 %= TABLE_SIZE;
            }
            table[hash1] = null;
            size--;
        }

        /* Function myhash which gives a hash value for a given string */
        private int Myhash1(string x)
        {
            int hashVal = x.GetHashCode();
            hashVal %= TABLE_SIZE;
            if (hashVal < 0)
                hashVal += TABLE_SIZE;
            return hashVal;
        }

        /* Function myhash function for double hashing */
        private int Myhash2(string x)
        {
            int hashVal = x.GetHashCode();
            hashVal %= TABLE_SIZE;
            if (hashVal < 0)
                hashVal += TABLE_SIZE;
            return primeSize - hashVal % primeSize;
        }

        /* Function to print hash table */
        public void PrintHashTable()
        {
            Console.WriteLine("Hash Table");
            for (int index = 0; index < TABLE_SIZE; index++)
                if (table[index] != null)
                    Console.WriteLine(table[index].key + " " + table[index].value);
        }
    }

    #endregion

    #region Extra

    //Implement multiple Q & Stack in one big array
    // A Class to represent x stacks and y queues in a single array of size n
    public class CatsAndDogs
    {
        int[] fullArr;   // Array of size n to store actual content to be stored
        int[] topOfStacks;   // Array of size k to store indexes of top elements of stacks
        int[] stackNexts;  // Array of size n to store next entry in all stacks
        int[] qFronts;   // Array of size k to store indexes of front elements of queue
        int[] qRears;   // Array of size k to store indexes of rear elements of queue
        int[] qNexts;  // Array of size n to store next entry in all queues

        int lengthOfArray, queueCount, stackCount;
        int free; // To store beginning index of free list

        //constructor to create k stacks in an array of size n
        public CatsAndDogs(int lengthOfArray, int queueCount, int stackCount)
        {
            // Initialize n and k, and allocate memory for all arrays
            this.lengthOfArray = lengthOfArray;
            this.queueCount = queueCount;
            this.stackCount = stackCount;

            fullArr = new int[this.lengthOfArray];
            topOfStacks = new int[this.stackCount];
            stackNexts = new int[this.lengthOfArray];
            
            qFronts = new int[this.lengthOfArray];
            qRears = new int[this.queueCount];
            qNexts = new int[this.lengthOfArray];

            // Initialize all stacks as empty
            for (int index = 0; index < stackCount; index++)
                topOfStacks[index] = -1;

            // Initialize all spaces as free
            free = 0;
            for (int index = 0; index < lengthOfArray - 1; index++)
                stackNexts[index] = index + 1;
            stackNexts[lengthOfArray - 1] = -1;  // -1 is used to indicate end of free list
        }

        // A utility function to check if there is space available
        bool IsFull() { return (free == -1); }

        // To push an item in stack number 'sn' where sn is from 0 to k-1
        void Push(int item, int sn)
        {
            // Overflow check
            if (IsFull())
            {
                Console.WriteLine("Stack Overflow");
                return;
            }

            int index = free;      // Store index of first free slot

            // Update index of free slot to index of next slot in free list
            free = stackNexts[index];

            // Update next of top and then top for stack number 'sn'
            stackNexts[index] = topOfStacks[sn];
            topOfStacks[sn] = index;

            // Put the item in array
            fullArr[index] = item;
        }

        // To pop an from stack number 'sn' where sn is from 0 to k-1
        int Pop(int sn)
        {
            // Underflow check
            if (IsStackEmpty(sn))
            {
                Console.WriteLine("Stack Underflow");
                return int.MaxValue;
            }


            // Find index of top item in stack number 'sn'
            int index = topOfStacks[sn];

            topOfStacks[sn] = stackNexts[index];  // Change top to store next of previous top

            // Attach the previous top to the beginning of free list
            stackNexts[index] = free;
            free = index;

            // Return the previous top item
            return fullArr[index];
        }

        // To check whether stack number 'sn' is empty or not
        bool IsStackEmpty(int sn) { return (topOfStacks[sn] == -1); }
        
        // To check whether queue number 'qn' is empty or not
        bool IsQEmpty(int qn) { return (qFronts[qn] == -1); }

        // To enqueue an item in queue number 'qn' where qn is from 0 to k-1
        public void Enqueue(int item, int qn)
        {
            // Overflow check
            if (IsFull())
            {
                Console.WriteLine("Queue Overflow");
                return;
            }

            int index = free;      // Store index of first free slot

            // Update index of free slot to index of next slot in free list
            free = qNexts[index];

            if (IsQEmpty(qn))
                qFronts[qn] = index;
            else
                qNexts[qRears[qn]] = index;

            qNexts[index] = -1;

            // Update next of rear and then rear for queue number 'qn'
            qRears[qn] = index;

            // Put the item in array
            fullArr[index] = item;
        }

        // To dequeue an from queue number 'qn' where qn is from 0 to k-1
        public int Dequeue(int qn)
        {
            // Underflow checkSAS
            if (IsStackEmpty(qn))
            {
                Console.WriteLine("Queue Underflow");
                return int.MaxValue;
            }

            // Find index of front item in queue number 'qn'
            int index = qFronts[qn];

           qFronts[qn] = qNexts[index];  // Change top to store next of previous top

            // Attach the previous front to the beginning of free list
            qNexts[index] = free;
            free = index;

            // Return the previous front item
            return fullArr[index];
        }
        
    }


    public class ShortestPath
    {
        // A utility function to find the vertex with minimum distance value,
        // from the set of vertices not yet included in shortest path tree
        static readonly int V = 9;

        public static int minDistance(int[] dist, Boolean[] sptSet)
        {
            // Initialize min value
            int min = int.MaxValue, min_index = -1;

            for (int v = 0; v < V; v++)
                if (sptSet[v] == false && dist[v] <= min)
                {
                    min = dist[v];
                    min_index = v;
                }

            return min_index;
        }

        // A utility function to print the constructed distance array
        public static void printSolution(int[] dist, int n)
        {
            Console.WriteLine("Vertex   Distance from Source");
            for (int i = 0; i < V; i++)
                Console.WriteLine(i + " \t\t " + dist[i]);
        }

        // Funtion that implements Dijkstra's single source shortest path
        // algorithm for a graph represented using adjacency matrix
        // representation
        public static void dijkstra(int[,] graph, int src)
        {
            int[] dist = new int[V]; // The output array. dist[i] will hold
                                     // the shortest distance from src to i

            // sptSet[i] will true if vertex i is included in shortest
            // path tree or shortest distance from src to i is finalized
            Boolean[] sptSet = new Boolean[V];

            // Initialize all distances as INFINITE and stpSet[] as false
            for (int i = 0; i < V; i++)
            {
                dist[i] = int.MaxValue;
                sptSet[i] = false;
            }

            // Distance of source vertex from itself is always 0
            dist[src] = 0;

            // Find shortest path for all vertices
            for (int count = 0; count < V - 1; count++)
            {
                // Pick the minimum distance vertex from the set of vertices
                // not yet processed. u is always equal to src in first
                // iteration.
                int u = minDistance(dist, sptSet);

                // Mark the picked vertex as processed
                sptSet[u] = true;

                // Update dist value of the adjacent vertices of the
                // picked vertex.
                for (int v = 0; v < V; v++)

                    // Update dist[v] only if is not in sptSet, there is an
                    // edge from u to v, and total weight of path from src to
                    // v through u is smaller than current value of dist[v]
                    if (!sptSet[v] && graph[u, v] != 0 &&
                            dist[u] != int.MaxValue &&
                            dist[u] + graph[u, v] < dist[v])
                        dist[v] = dist[u] + graph[u, v];
            }

            // print the constructed distance array
            printSolution(dist, V);
        }
    }

    public class Meeting
    {
        public int Start, End;

        private int gap = 30, startDay = 9;
        private Meeting()
        { }

        public Meeting(int start, int end)
        {
            this.Start = start;
            this.End = end;
        }

        public string Duration()
        {
            return string.Format("Starting time: {0} hrs & Ending time: {1} hrs.", (startDay + (gap * Start)), (startDay + (gap * End)));
        }
    }
    #endregion
}
